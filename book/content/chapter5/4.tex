Understanding targets is critical to writing clean, modern CMake projects. In this chapter, we have not only discussed what constitutes a target and how to define three different types of targets: executables, libraries, and custom targets. We have also explained how targets depend on each other through a dependency graph and we learned how to visualize it using the Graphviz module. With this general understanding, we were able to learn about the key feature of targets – properties. We not only went through a few commands to set regular properties on targets but we also solved the mystery of Transitive Usage Requirements also known as propagated properties.

This was a hard one to crack, as we had to not only understand how to control which properties are propagated but also how that propagation affects subsequent targets. Furthermore, we discovered how to guarantee the compatibility of properties consumed from multiple sources.

We then briefly discussed pseudo targets: imported targets, alias targets, and interface libraries. All of them will come in handy later in our projects, especially when we know how to connect them with propagated properties for our benefit. Then, we talked about generated build targets and how the configuration stage affects them. Afterward, we spent some time looking at a mechanism that is similar to targets, but not exactly it: the custom commands. We touched on how they can generate files consumed by other targets (compiled, translated, and so on) and their hooking function: executing additional steps when a target is built.

With such a solid foundation, we are ready for the next topic – compiling C++ sources into executables and libraries.