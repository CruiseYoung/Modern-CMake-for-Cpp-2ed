
Many generator expressions are available, but to avoid getting lost in the weeds, let’s focus on the most common ones. We’ll start with some basic transformations of the available data.

\mySubsubsection{6.5.1.}{Dealing with strings, lists, and paths}

Generator expressions provide only the bare minimum of operations to transform and query data structures. Working with strings in the generator stage is possible with the following expressions:

\begin{itemize}
\item
\$<LOWER\_CASE:string>, \$<UPPER\_CASE:string>: This converts to string to the required case.
\end{itemize}

List operations were fairly limited until recently. Since CMake 3.15, the following operations have been available:

\begin{itemize}
\item
\$<IN\_LIST:string,list>: This returns true if list contains a string value.

\item
\$<JOIN:list,d>: This joins a semicolon-separated list using a d delimiter.

\item
\$<REMOVE\_DUPLICATES:list>: This deduplicates list (without sorting).

\item
\$<FILTER:list,INCLUDE|EXCLUDE,regex>: This includes/excludes items from list using a regex.
\end{itemize}

Since 3.27, the \$<LIST:OPERATION> generator expressions were added, where OPERATION is one of:

\begin{itemize}
\item
LENGTH

\item
GET

\item
SUBLIST

\item
FIND

\item
JOIN

\item
APPEND

\item
PREPEND

\item
INSERT

\item
POP\_BACK

\item
POP\_FRONT

\item
REMOVE\_ITEM

\item
REMOVE\_AT

\item
REMOVE\_DUPLICATES

\item
FILTER

\item
TRANSFORM

\item
REVERSE

\item
SORT
\end{itemize}

It’s rather rare to work with lists in generator expressions, so we’re only indicating what’s possible. If you find yourself in one of these cases, see the online manual for instructions on how to use these operations.

Finally, we can query and transform the system paths. It’s a useful addition because of its portability across different operating systems. The following simple queries have been available since CMake 3.24:

\begin{itemize}
\item
\$<PATH:HAS\_ROOT\_NAME,path>

\item
\$<PATH:HAS\_ROOT\_DIRECTORY,path>

\item
\$<PATH:HAS\_ROOT\_PATH,path>

\item
\$<PATH:HAS\_FILENAME,path>

\item
\$<PATH:HAS\_EXTENSION,path>

\item
\$<PATH:HAS\_STEM,path>

\item
\$<PATH:HAS\_RELATIVE\_PART,path>

\item
\$<PATH:HAS\_PARENT\_PATH,path>

\item
\$<PATH:IS\_ABSOLUTE,path>

\item
\$<PATH:IS\_RELATIVE,path>

\item
\$<PATH:IS\_PREFIX[,NORMALIZE],prefix,path>: This returns true if prefix is the prefix of path
\end{itemize}

Analogically, we can retrieve all the path components we were able to check for (since CMake 3.27, it’s been possible to provide a list of paths rather than just one path):

\begin{itemize}
\item
\$<PATH:CMAKE\_PATH[,NORMALIZE],path...>

\item
\$<PATH:APPEND,path...,input,...>

\item
\$<PATH:REMOVE\_FILENAME,path...>

\item
\$<PATH:REPLACE\_FILENAME,path...,input>

\item
\$<PATH:REMOVE\_EXTENSION[,LAST\_ONLY],path...>

\item
\$<PATH:REPLACE\_EXTENSION[,LAST\_ONLY],path...,input>

\item
\$<PATH:NORMAL\_PATH,path...>

\item
\$<PATH:RELATIVE\_PATH,path...,base\_directory>

\item
\$<PATH:ABSOLUTE\_PATH[,NORMALIZE],path...,base\_directory>
\end{itemize}

Additionally, some transform operations were introduced in 3.24; we’ll just list them for completeness:

\begin{itemize}
\item
\$<PATH:CMAKE\_PATH[,NORMALIZE],path...>

\item
\$<PATH:APPEND,path...,input,...>

\item
\$<PATH:REMOVE\_FILENAME,path...>

\item
\$<PATH:REPLACE\_FILENAME,path...,input>

\item
\$<PATH:REMOVE\_EXTENSION[,LAST\_ONLY],path...>

\item
\$<PATH:REPLACE\_EXTENSION[,LAST\_ONLY],path...,input>

\item
\$<PATH:NORMAL\_PATH,path...>

\item
\$<PATH:RELATIVE\_PATH,path...,base\_directory>

\item
\$<PATH:ABSOLUTE\_PATH[,NORMALIZE],path...,base\_directory>
\end{itemize}

There’s one more path operation, which formats the provided path to the style supported by the shell of the host: \$<SHELL\_PATH:path...>.

Again, previous expressions are introduced for later reference, not as information that you need to memorize right now. The bulk of the recommended practical knowledge is detailed in the subsequent sections.


\mySubsubsection{6.5.2.}{Parametrizing the build configuration and platform}

One of the key pieces of information that CMake users will provide when building a project is the desired build configuration. In most cases, it will be Debug or Release. We can use the generator expressions to access these values through the following statements:

\begin{itemize}
\item
\$<CONFIG>: This returns the current build configuration as a string: Debug, Release, or another.

\item
\$<CONFIG:configs>: This returns true if configs contains the current build configuration (case-insensitive comparison).
\end{itemize}

We discussed the platform in the Chapter 4, Setting Up Your First CMake Project in the Understanding the build environment section. We can read related information the same way as with configuration:

\begin{itemize}
\item
\$<PLATFORM\_ID>: This returns the current platform ID as a string: Linux, Windows, or Darwin for macOS.

\item
\$<PLATFORM\_ID:platform> is true if platform contains the current platform ID.
\end{itemize}

Such configuration or platform-specific parametrization is a powerful addition to our toolbelt. We can use it in conjunction with the conditional expansion we discussed earlier:

\begin{shell}
$<IF:condition,true_string,false_string>
\end{shell}

For example, we may apply one compilation flag when building test binaries, and another for production:

\begin{cmake}
target_compile_definitions(my_target PRIVATE
    $<IF:$<CONFIG:Debug>,Test,Production>
)
\end{cmake}

But this is just the beginning. There are plenty of other circumstances we can address with generator expressions. Of course, the next important aspect is the tooling present in the system.

\mySubsubsection{6.5.3.}{Tuning for toolchain}

Toolchains, toolkits, or, simply, compilers and linkers luckily (sadly?) aren’t consistent across vendors. This has all sorts of consequences. Some of them are great (better performance in special cases), others not so much (varied configuration flavors, discrepancies in flag naming, and more).

Generator expressions help here by providing sets of queries that can be utilized to alleviate problems and opportunistically improve user experience where possible.

As with the build configurations and platform, there are multiple expressions that return information about the toolchain, both as string and Boolean. However, we’re required to specify which language we’re interested in (replace \#LNG with one of C, CXX, CUDA, OBJC, OBJCXX, Fortran, HIP, or ISPC). Support for HIP was added in 3.21.

\begin{itemize}
\item
\$<\#LNG\_COMPILER\_ID>: This returns CMake’s compiler ID of the \#LNG compiler used.

\item
\$<\#LNG\_COMPILER\_VERSION>: This returns CMake’s compiler version of the \#LNG compiler used.
\end{itemize}

To check which compiler will execute for C++, we should use the \$<CXX\_COMPILER\_ID> generator expression. The returned value, the CMake’s compiler ID, is a constant defined for every supported compiler. You may encounter values like AppleClang, ARMCC, Clang, GNU, Intel, and MSVC. For the full list, check the official documentation (URL in the Further reading section).

Similarly to the previous section, we can also utilize the toolchain information in conditional expressions. There are multiple queries that return true if any of the provided arguments matches a specific value:

\begin{itemize}
\item
\$<\#LNG\_COMPILER\_ID:ids>: This returns true if ids contains CMake’s \#LNG compiler ID.

\item
\$<\#LNG\_COMPILER\_VERSION:vers>: This returns true if vers contains the CMake’s \#LNG compiler version.

\item
\$<COMPILE\_FEATURES:features>: This returns true if all features provided in features are supported by the compiler for this target.
\end{itemize}

Inside commands requiring a target argument, like target\_compile\_definitions(), we can use one of the target-specific expressions to get a string value:

\begin{itemize}
\item
\$<COMPILE\_LANGUAGE>: This returns the language of source files at the compilation step.

\item
\$<LINK\_LANGUAGE>: This returns the language of source files at the link step.
\end{itemize}

To evaluate a simple Boolean query:

\begin{itemize}
\item
\$<COMPILE\_LANGUAGE:langs>: This returns true if langs contains a language used for the compilation of this target. This can be used to provide language-specific flags to the compiler. For example, to compile C++ sources of the target with the -fno-exceptions flag:

\begin{cmake}
target_compile_options(myapp
    PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-fno-exceptions>
)
\end{cmake}

\item
\$<LINK\_LANGUAGE:langs> – It follows the same rules as COMPILE\_LANGUAGE and returns true if langs contains a language used for linking of this target.
\end{itemize}

Or, to query more complex scenarios:

\begin{itemize}
\item
\$<COMPILE\_LANG\_AND\_ID:lang,compiler\_ids...>: This returns true if the lang language is used for this target, and one of the compilers in the compiler\_ids list will be used for this compilation. This expression is useful to specify compile definitions for specific compilers:

\begin{cmake}
target_compile_definitions(myapp PRIVATE
    $<$<COMPILE_LANG_AND_ID:CXX,AppleClang,Clang>:CXX_CLANG>
    $<$<COMPILE_LANG_AND_ID:CXX,Intel>:CXX_INTEL>
    $<$<COMPILE_LANG_AND_ID:C,Clang>:C_CLANG>
)
\end{cmake}

\item
In this example, for C++ sources (CXX) compiled with AppleClang or Clang, the -DCXX\_CLANG definition will be set. For the C++ sources compiled with the Intel compiler, the -DCXX\_INTEL definition flag will be set. Lastly, for the C sources (C) compiled with the Clang compiler, we’ll set a -DC\_CLANG definition.

\item
\$<LINK\_LANG\_AND\_ID:lang,compiler\_ids...>: This works like COMPILE\_LANG\_AND\_ID, but checks the language used for the link step instead. Use this expression to specify link libraries, link options, link directories, and link dependencies of a particular language and a linker combination in a target.
\end{itemize}

An important note to make here is that a single target can be combined from sources of multiple languages. For example, it’s possible to link C artifacts with C++ (but we should declare both languages in the project() command). Therefore, generator expressions referencing a specific language will be used for some source files, but not for others.

Let’s move on to the next important category: target-related generator expressions.

\mySubsubsection{6.5.4.}{Querying target-related information}

There are plenty of generator expressions that query target properties and check target-related information. Note that until CMake 3.19, many target expressions referencing another target were used to automatically create a dependency between them. This no longer happens in the latest versions of CMake.

Some generator expressions will infer the target from the command being called; the most commonly used is the basic query that returns the target’s property value:

\begin{shell}
$<TARGET_PROPERTY:prop>
\end{shell}

\begin{itemize}
\item
Less known, but useful in the target\_link\_libraries() command, is the \$<LINK\_ONLY:deps> generator expression. It allows us to store the PRIVATE link dependencies, which won’t be propagated through transitive usage requirements; these are used in interface libraries, which we discussed in Chapter 5, Working with Targets, in the Understanding the transitive usage requirements section.
\end{itemize}

There also is a set of install and export-related expressions, which infer their targets from the context they’re being used. We’ll discuss them in depth in Chapter 14, Installing and Packaging, so we can just have a quick introduction for now:

\begin{itemize}
\item
\$<INSTALL\_PREFIX>: This returns the install prefix when the target is exported with install(EXPORT) or when evaluated in INSTALL\_NAME\_DIR; otherwise, it is empty.

\item
\$<INSTALL\_INTERFACE:string>: This returns string when the expression is exported with install(EXPORT).

\item
\$<BUILD\_INTERFACE:string>: This returns string when the expression is exported with the export() command or by another target in the same buildsystem.

\item
\$<BUILD\_LOCAL\_INTERFACE:string>: This returns string when the expression is exported by another target in the same buildsystem.
\end{itemize}

However, most queries require the target name to be explicitly provided as the first argument:

\begin{itemize}
\item
\$<TARGET\_EXISTS:target>: This returns true if the target exists.

\item
\$<TARGET\_NAME\_IF\_EXISTS:target>: This returns the target name if the target exists and an empty string otherwise.

\item
\$<TARGET\_PROPERTY:target,prop>: This returns the prop property value for the target.

\item
\$<TARGET\_OBJECTS:target>: This returns a list of object files for an object library target.
\end{itemize}

You can query the path of the target artifact:

\begin{itemize}
\item
\$<TARGET\_FILE:target>: This returns the full path.

\item
\$<TARGET\_FILE\_NAME:target>: This returns just the filename.

\item
\$<TARGET\_FILE\_BASE\_NAME:target>: This returns the base name.

\item
\$<TARGET\_FILE\_NAME:target>: This returns the base name without the prefix or suffix (for libmylib.so the base name would be mylib).

\item
\$<TARGET\_FILE\_PREFIX:target>: This returns just the prefix (for example, lib).

\item
\$<TARGET\_FILE\_SUFFIX:target>: This returns just the suffix (for example, .so or .exe).

\item
\$<TARGET\_FILE\_DIR:target>: This returns the directory.
\end{itemize}

There are families of expressions that offer similar functionality as the regular TARGET\_FILE expression (each expression also accepts the \_NAME, \_BASE\_NAME or \_DIR suffix):

\begin{itemize}
\item
TARGET\_LINKER\_FILE: This queries the path of the file used when linking to the target. Usually, it is the library produced by the target (.a, .lib, .so). However, on platforms with Dynamic-Link Libraries (DLLs), it will be a .lib import library associated with the target’s DLL.

\item
TARGET\_PDB\_FILE: This queries the path of the linker-generated program database file (.pdb).
\end{itemize}

Managing libraries is a complex topic, and CMake offers a lot of generator expressions to help. However, we’ll postpone introducing them until they become relevant in Chapter 8, Linking Executables and Libraries.

Finally, there are some Apple package-specific expressions as well:

\begin{itemize}
\item
\$<TARGET\_BUNDLE\_DIR:target>: This is the full path to the bundle directory (my.app, my.framework, or my.bundle) for the target.

\item
\$<TARGET\_BUNDLE\_CONTENT\_DIR:target>: This is the full path to the bundle content directory for the target. On macOS, it’s my.app/Contents, my.framework, or my.bundle/Contents. Other Software Development Kits (SDKs) (such as iOS) have a flat bundle structure – my.app, my.framework, or my.bundle.
\end{itemize}

These are the main generator expressions for dealing with targets. It’s worth knowing, there’s plenty more. I recommend referring to the official documentation for a complete list.

\mySubsubsection{6.5.5.}{Escaping}

On a rare occasion, you may need to pass a character to a generator expression that has a special meaning. To escape this behavior, use the following expressions:

\begin{itemize}
\item
\$<ANGLE-R>: This a literal > symbol

\item
\$<COMMA>: This a literal , symbol

\item
\$<SEMICOLON>: This a literal ; symbol
\end{itemize}

The last expression can be useful to prevent list expansion when an argument containing ; is used.

Now that we have introduced all the queries and transformations, we can see how they work in practice. Let’s go through some examples of applications.









