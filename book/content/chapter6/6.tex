
一切在有了好的实际例子的支持下，理论都更容易掌握。显然，我们想要编写一些 CMake 代码并尝试一下。然而，由于生成器表达式直到配置完成之后才被评估，我们不能使用任何配置时的命令，如 message() 来实验。我们需要使用一些特殊的技巧 instead. 为了调试生成器表达式，你可以使用以下任一方法：

\begin{itemize}
\item
将其写入文件（这个 file() 命令的特定版本支持生成器表达式）： file(GENERATE OUTPUT filename CONTENT "\$<...>")

\item
添加一个自定义目标，并从命令行显式构建它： add\_custom\_target(gendbg COMMAND \$\{CMAKE\_COMMAND\} -E echo "\$<...>")
\end{itemize}

我推荐第一个选项进行简单的练习。请记住，我们无法在这些命令中使用所有的表达式，因为有些是特定于目标的。

了解了这一点，让我们看一下生成器表达式的某些用途。

\mySubsubsection{6.6.1.}{构建配置}

在第一章《CMake的初步步骤》中，我们讨论了构建类型，指定我们正在构建的配置——Debug、Release 等。可能有些情况下，你希望根据你正在进行的构建类型进行不同的操作。一个简单且直接的方法是使用\$<CONFIG>生成器表达式：

\begin{shell}
target_compile_options(tgt $<$<CONFIG:DEBUG>:-ginline-points>)
\end{shell}

前面的例子检查配置是否等于 DEBUG；如果是这样，嵌套表达式被评估为 1。然后外部的简写 if 表达式变为真，我们的 -ginline-points 调试标志被添加到选项中。了解这种形式很重要，这样你将能够理解其他项目中的此类表达式，但我建议为了更好的可读性，使用更详细的\$<IF:...>.

\mySubsubsection{6.6.2.}{系统特定的单行命令}

生成器表达式还可以用来将冗长的 if 命令压缩成整洁的单行命令。

假设我们有以下代码：

\begin{cmake}
if (${CMAKE_SYSTEM_NAME} STREQUAL "Linux")
    target_compile_definitions(myProject PRIVATE LINUX=1)
endif()
\end{cmake}

它告诉编译器，如果这是目标系统，则向参数中添加 -DLINUX=1。虽然这并不算太长，但它可以被一个相当简单的表达式替换：

\begin{cmake}
target_compile_definitions(myProject PRIVATE
                           $<$<CMAKE_SYSTEM_NAME:LINUX>:LINUX=1>)
\end{cmake}

这样的代码运行良好，但是你可以在生成器表达式中打包的内容有限，直到它变得难以阅读。此外，许多 CMake 用户推迟学习生成器表达式，并难以跟踪发生的事情。幸运的是，在完成本章后，我们不会遇到这样的问题。

\mySubsubsection{6.6.3.}{带有编译器特定标志的接口库}

如我们在第五章《与目标打交道》中讨论的，接口库可以用来提供与编译器匹配的标志：

\begin{cmake}
add_library(enable_rtti INTERFACE)
target_compile_options(enable_rtti INTERFACE
    $<$<OR:$<COMPILER_ID:GNU>,$<COMPILER_ID:Clang>>:-rtti>
)
\end{cmake}

即使在如此简单的例子中，当我们嵌套太多生成器表达式时，理解表达式也是困难的。不幸的是，有时这是实现期望效果的唯一方式。以下是例子的解释：

\begin{itemize}
\item
我们检查 COMPILER\_ID 是否为 GNU；如果是，我们将 OR 评估为 1。

\item
如果不是，我们检查 COMPILER\_ID 是否为 Clang，并将 OR 评估为 1。否则，将 OR 评估为 0。

\item
如果 OR 被评估为 1，将 -rtti 添加到 enable\_rtti 编译选项中。否则，不做任何事情。
\end{itemize}

接下来，我们可以将我们的库和可执行文件与 enable\_rtti 接口库链接起来。如果编译器支持，CMake 将添加 -rtti 标志。旁注：RTTI 代表运行时类型信息，在 C++ 中与 typeid 等关键字一起使用，以在运行时确定对象的类；除非你的代码使用这个功能，否则不需要启用该标志。

\mySubsubsection{6.6.4.}{嵌套生成器表达式}

有时，当我们尝试在生成器表达式中嵌套元素时，会发生什么并不明显。我们可以通过生成一个测试输出到调试文件来调试表达式。

让我们尝试一些事情，看看会发生什么：

\filename{ch06/01-nesting/CMakeLists.txt}

\begin{cmake}
set(myvar "small text")
set(myvar2 "small text >")

file(GENERATE OUTPUT nesting CONTENT "
    1 $<PLATFORM_ID>
    2 $<UPPER_CASE:$<PLATFORM_ID>>
    3 $<UPPER_CASE:hello world>
    4 $<UPPER_CASE:${myvar}>
    5 $<UPPER_CASE:${myvar2}>
")
\end{cmake}

在按照本章技术要求部分描述的方法构建此项目后，我们可以使用 Unix 的 cat 命令读取生成的 nesting 文件：

\begin{shell}
# cat nesting

    1 Linux
    2 LINUX
    3 HELLO WORLD
    4 SMALL TEXT
    5 SMALL text>
\end{shell}

这就是每行的工作方式：

\begin{enumerate}
\item
PLATFORM\_ID 的输出值是 LINUX。

\item
嵌套值的输出将被正确地转换为大写的 LINUX。

\item
我们可以转换普通字符串。

\item
我们可以转换配置阶段的变量内容。

\item
变量将首先插值，然后闭合的尖括号（>）将被解释为生成器表达式的一部分，因此只有字符串的一部分将被大写。
\end{enumerate}

换句话说，请注意，变量的内容可能会影响你的 genex 扩展的行为。如果你需要在变量中使用尖括号，请使用\$<ANGLE-R>。

\mySubsubsection{6.6.5.}{布尔表达式与 BOOL 运算符的评估差异}

当涉及到将布尔类型评估为字符串时，生成器表达式可能会有些令人困惑。了解它们与常规条件表达式的区别至关重要，尤其是从显式的 IF 关键字开始：

\filename{ch06/02-boolean/CMakeLists.txt}

\begin{cmake}
cmake_minimum_required(VERSION 3.26)
project(Boolean CXX)

file(GENERATE OUTPUT boolean CONTENT "
    1 $<0:TRUE>
    2 $<0:TRUE,FALSE> (won't work)
    3 $<1:TRUE,FALSE>
    4 $<IF:0,TRUE,FALSE>
    5 $<IF:0,TRUE,>
")
\end{cmake}

让我们使用 Linux 的 cat 命令读取生成的文件：

\begin{enumerate}
\item
这是一个布尔展开，其中 BOOL 是 0；因此，TRUE 字符串不会被写入。

\item
这是一个典型的错误——作者原本打算根据 BOOL 值打印 TRUE 或 FALSE，但由于它也是一个布尔假展开，两个参数被当作一个参数处理，因此不会被打印。

\item
这是相同错误的一个反转值——它是一个布尔真展开，两者都在同一行写入。

\item
这是一个以 IF 开头的正确条件表达式——它打印 FALSE，因为第一个参数是 0。

\item
这是条件表达式的正确用法，但是当我们不需要为布尔假提供值时，我们应该使用第一行中使用的形式。
\end{enumerate}

生成器表达式因其复杂的语法而臭名昭著。本例中提到的差异甚至可能会让经验丰富的构建者感到困惑。如果有所疑虑，将这样的表达式复制到另一个文件中，并通过添加缩进和空格来分析它，以更好地理解。

看到生成器表达式的工作示例已经为我们使用它们做好了准备。接下来的章节将讨论许多主题，其中生成器表达式将是相关的。随着时间的推移，我们将涵盖它们更多的应用。






