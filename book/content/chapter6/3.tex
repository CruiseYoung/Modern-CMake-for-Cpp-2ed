
要使用生成器表达式，需要将其添加到支持生成器表达式计算的CMake命令中。大多数特定于目标的命令都支持，还有许多其他命令（查看特定命令的官方文档以了解更多信息）。

一个经常与生成器异常一起使用的命令是target\_compile\_definitions()。要使用生成器表达式，需要将其作为命令参数提供，如下所示：

\begin{cmake}
target_compile_definitions(foo PUBLIC BAR=$<TARGET_FILE:baz>)
\end{cmake}

这个命令向编译器的参数中添加了一个-D定义标志（先忽略PUBLIC），将BAR预处理器定义设置为foo目标产生的二进制工件的路径(生成器表达式以当前形式存储在变量中)。这种扩展推迟到了生成阶段，那时许多事情都已经配置并已知。

生成器表达式是什么样的呢？

\myGraphic{0.4}{content/chapter6/images/1.png}{图6.1：生成器表达式的语法}

如图6.1所示，结构看起来相当简单：

\begin{itemize}
\item
以美元符号和左括号（\$<）开始。

\item
添加EXPRESSION名称。

\item
如果表达式需要参数，添加冒号（:）并提供arg1, arg2 … argN值，用逗号（,）分隔。

\item
以大于号（>）结束表达式。
\end{itemize}

有些表达式不需要参数，例如\$<PLATFORM\_ID>。

除非明确指出，否则表达式通常是在使用表达式的目标上下文中进行计算的。这种关联是从使用表达式的命令中推断出的。前面的例子中，了解了target\_compile\_definitions()是如何提供foo作为其操作的目标。因此，在该命令中使用的特定于目标的生成器表达式将隐式地使用foo。注意，示例中使用的生成器表达式\$<TARGET\_FILE>需要目标属性作为其操作的上下文。还有一些生成器表达式不接受目标作为参数（如\$<COMPILE\_LANGUAGE>），将隐式地使用封闭命令的目标。这些将在后面详细讨论。

当使用生成器表达式的更高级功能时，可能会很快变得非常混乱和复杂，事先了解其细节信息非常重要。

\mySubsubsection{6.3.1.}{嵌套}

让我们从生成式表达式的嵌套开始介绍。即支持将生成器表达式作为参数，传递给另一个生成器表达式：

\begin{shell}
$<UPPER_CASE:$<PLATFORM_ID>>
\end{shell}

这个例子并不复杂，但很容易想象当增加嵌套级别，并在使用多个参数的命令中工作时会发生什么。

为了进一步复杂化，可以将常规变量在其中展开：

\begin{shell}
$<UPPER_CASE:${my_variable}>
\end{shell}

变量my\_variable将首先在配置阶段展开，生成器表达式将在生成阶段展开。这个特性有一些罕见的使用场景，但我强烈建议避免使用这种方式：生成器表达式提供了几乎所有必要的功能。将这些常规变量混合到表达式中增加了一层难以调试的间接性。此外，在配置阶段收集的信息通常会过时，因为用户会在构建或安装阶段通过命令行参数覆盖生成器表达式中使用的值。

了解了语法之后，让我们继续讨论生成器表达式中的基本机制。













