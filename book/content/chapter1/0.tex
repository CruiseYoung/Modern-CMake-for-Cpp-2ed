There is something magical about software creation. We’re not only creating a working mechanism that gets brought to life but we’re also often authoring the very idea behind the functionality of the solution.

To cast our ideas into existence, we work in the following loop: design, code, and test. We invent changes, we phrase them in a language that the compiler understands, and we check whether they work as intended. To create proper, high-quality software from our source code, we need to meticulously execute repetitive, error-prone tasks: invoking the correct commands, checking the syntax, linking binary files, running tests, reporting issues, and more.

It takes great effort to remember each step every single time. Instead, we want to stay focused on the actual coding and delegate everything else to automated tooling. Ideally, this process would start with a single button, right after we have changed our code. It would be smart, fast, extensible, and work in the same way across different OSs and environments. It would be supported by multiple Integrated Development Environments (IDEs). Going even further, we could streamline this process into Continuous Integration (CI) pipelines that build and test our software every time a change is submitted to a shared repository.

CMake is the answer to many such needs; however, it requires a bit of work to configure and use correctly. CMake isn’t the source of the complexity; that stems from the subject that we’re dealing with here. Don’t worry, we will go through this whole learning process very methodically. Before you know it, you will become a software-building guru.

I know you’re eager to rush off to start writing your own CMake projects, and this is exactly what we will be doing for most of this book. But since you’ll be creating your projects primarily for users (yourself included), it’s important for you to understand their perspective first.

So, let’s start with just that: becoming a CMake power user. We’ll go through a few basics: what this tool is, how it works in principle, and how to install it. Then, we’ll do a deep dive into the command line and modes of operation. Finally, we’ll wrap up with the purposes of different files in a project, and we’ll explain how to use CMake without creating projects at all.

In this chapter, we’re going to cover the following main topics:

\begin{itemize}
\item
Understanding the basics

\item
Installing CMake on different platforms

\item
Mastering the command line

\item
Navigating project files

\item
Discovering scripts and modules
\end{itemize}
























