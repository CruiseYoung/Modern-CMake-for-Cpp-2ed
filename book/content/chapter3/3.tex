
Visual Studio Code (VS Code) is a free, cross-platform IDE available for Windows, macOS, and Linux, developed by Microsoft. Don’t confuse it with another Microsoft product, the Visual Studio IDE (usually named after the year it was released, for example, Visual Studio 2022).

VS Code is favored for its vast extension ecosystem and support for hundreds of programming languages (an estimated are over 220 different languages!). When GitHub was acquired by Microsoft, VS Code was introduced as something of a replacement for Atom.

The overall design of the IDE is top-notch, as you can see in Figure 3.4.

\myGraphic{1.0}{content/chapter3/images/4.png}{Figure 3.4: The main window of VS Code}

Now, let’s find out what makes VS Code so special.

\mySubsubsection{3.3.1}{Why you might like it}

C++ isn’t the priority in terms of languages supported by VSC, but it’s quite close to the top, thanks to the many sophisticated language extensions available. This trade-off is rewarded with the ability to switch between many languages as needed while working in the same environment.

There’s a bit of a learning curve to this tool, as most extensions conform to the basic UI functionalities provided, rather than implementing advanced interfaces on their own. Many of the features will be available through the command palette (accessible by pressing F1), which requires you to type the name of the command instead of clicking an icon or a button. This is a reasonable sacrifice to keep VSC clean, fast, and free of charge. In fact, this IDE is so quick to load that I prefer to use it as a general-purpose text editor, even when I’m not working on a project.

That said, VS Code is truly powerful thanks to an enormous library of really good extensions, the vast majority of which are available for free. There are special extensions available for C++ and CMake, so let’s see how to configure them in the next section.

\mySubsubsection{3.3.2}{Take your first steps}

VSC is available from the official website: \url{https://code.visualstudio.com/}. The website provide quite an extensive list of downloads for Windows and macOS, as well as for many Linux distributions: Debian, Ubuntu, Red Hat, Fedora, and SUSE. Follow the usual process on your platform to install the software. After that, you’ll want to install a bunch of extensions by going to the Extensions Marketplace (Ctrl/Command + Shift + X). The following are recommended to start with:

\begin{itemize}
\item
C/C++ by Microsoft

\item
C/C++ Extension Pack by Microsoft

\item
CMake by twxs

\item
CMake Tools by Microsoft
\end{itemize}

They will provide the usual code highlighting and the ability to compile, run, and debug code straight from the IDE, but you might need to install the toolchain yourself. Usually, VS Code will suggest extensions to install in a pop - up window as you start opening relevant files, so you don’t necessarily need to go out on a hunt.

I also suggest installing the Remote – SSH by Microsoft extension if you’re involved with remote projects, as this will make the experience much more coherent and comfortable; this extension not only takes care of file synchronization but will also enable you to remotely debug by attaching to the debugger on the remote machine.

However, there’s one more interesting extension that shifts the paradigm of working with projects; let’s see how.

\mySubsubsection{3.3.3}{Advanced feature: Dev Containers}

If you’re deploying your application to a production environment, whether you’re shipping the compiled artifact or running a build process, it’s crucial to ensure that all dependencies are present. Otherwise, you’ll get all sorts of problems. Even with all dependencies accounted for, different versions or configurations might cause your solution to behave differently from the development or staging environment. I’ve experienced such cases on numerous occasions. Before virtualization became prevalent, dealing with environmental issues was just a part of life.

With the introduction of lightweight containers like Docker, things got much simpler. Suddenly, you were able to run a minified operating system with your service isolated to its own space. This isolation allowed all dependencies to be packaged with the container, freeing developers from a major headache.

Until recently, developing inside a container involved manually building, running, and connecting to the container with a remote session from the IDE. This process wasn’t overly difficult, but it required manual steps that could be executed differently by various developers.

In recent years, Microsoft released an open standard called Dev Containers (\url{https://containers.dev/}) to help address this slight inconvenience. The specification mainly consists of a devcontainer.json file that you can place in your project repository, instructing IDEs on how to set up their development environment in a container.

To use this feature, simply install the Dev Containers by Microsoft extension and point it to a repository of an appropriately prepared project. If you’re undeterred by the challenges of switching the main CMakeLists.txt, feel free to try it with the book’s repository:

\url{git@github.com:PacktPublishing/Modern-CMake-for-Cpp-2E.git}

I can confirm that other IDEs, like CLion, are adopting this standard, so it seems like a good practice to adopt if you’re facing the circumstances described. Time to move on to the next product from the Microsoft family.


















