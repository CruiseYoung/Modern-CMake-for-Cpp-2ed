We have gathered all the necessary knowledge to build professional projects, including structuring, building, dependency management, testing, analyzing, installing, and packaging. Now, it’s time to apply these skills by creating a coherent, professional project. It’s important to understand that even trivial programs benefit from automated quality checks and a seamless process that transforms raw code into a complete solution. It’s true that implementing these checks and processes is a significant investment, as it requires many steps to set up everything correctly. This is especially true when adding these mechanisms to existing code bases, which are often large and complex. That’s why it’s beneficial to use CMake from the start and establish all the necessary processes early on. It’s easier to configure and more efficient, as such quality controls and build automation will eventually need to be integrated into long-term projects anyway.

In this chapter, we will develop a new solution that is as small as possible, while making the most of the CMake practices we discussed in the book so far. To keep it simple, we will implement only a single practical function – adding two numbers. Such basic business code will allow us to focus on the build-related aspects of the project we learned in previous chapters. To tackle a more challenging problem related to building, this project will include both a library and an executable.

The library will handle the internal business logic and be available as a CMake package for other projects. The executable, intended for end users, will provide a user interface demonstrating the library’s functionality.

To sum that up, in this chapter, we’re going to cover the following main topics:

\begin{itemize}
\item
Planning our work

\item
Project layout

\item
Building and managing dependencies

\item
Testing and program analysis

\item
Installing and packaging

\item
Providing the documentation
\end{itemize}