本章将构建的软件并不复杂——将创建一个简单的计算器，可以实现两个数字的相加（图15.1）。这是一个控制台应用程序，具有文本用户界面，利用第三方库和独立的计算库，这些库可以用于其他项目。尽管这个项目可能没有重要的实际应用，但其简单性非常适合演示本书讨论的各种技术应用。

\myGraphic{0.4}{content/chapter15/images/1.png}{图15.1：项目在支持鼠标的终端中执行的文本用户界面}

通常，项目要么生成面向用户的可执行文件，要么为开发者生成库。项目同时产生这两者的情况较少，尽管这种情况确实存在。例如，一些应用程序附带了独立的SDK或库以帮助开发插件。另一个例子是附带了使用示例的库。我们的项目属于后者，展示了库的功能。

我们将通过回顾章节列表，回忆每个章节的内容，并选择将用来构建应用程序的技术和工具来开始规划：

\begin{itemize}
\item
第1章，CMake入门：

本章提供了关于CMake的基本细节，包括安装和用于构建项目的命令行使用。还包含了关于项目文件的基本信息，如作用、典型的命名约定和特殊性。

\item
第2章，CMake语言：

我们介绍了编写正确的CMake列表文件和脚本所需的工具，包含了代码基础，如注释、命令调用和参数。我们解释了变量、列表和控制结构，引入了几个有用的命令。这个基础在我们的项目中至关重要。

\item
第3章，在IDE中使用CMake：

我们讨论了三个IDE——CLion、VS Code和Visual Studio IDE，介绍了它们的优点。在最终项目中，选择IDE（或不选择）由你决定。做出决定后，可以在这个项目中使用Dev容器开始，只需几个步骤就可以构建Docker镜像（或者直接从Docker Hub获取）。在容器中运行镜像可以确保开发环境与生产环境相匹配。

\item
第4章，设置CMake项目：

配置项目至关重要，其决定了将生效的CMake策略、命名、版本控制和编程语言。我们将使用本章来影响构建过程的基本行为。

我们还将遵循建立的项目分区和结构来确定目录和文件的布局，并利用系统发现变量以适应不同的构建环境。工具链配置是另一个关键方面，可以强制使用特定的C++版本和编译器支持的标准。按照章节的建议，我们将禁用源内构建以保持工作区清洁。

\item
第5章，使用目标：

了解到每个现代CMake项目都广泛使用目标，当然也会应用目标来定义一些库和可执行文件（用于测试和生产），这将使项目保持组织并确保我们遵循DRY（不要重复自己）的原则。对目标属性和传递使用要求（传播属性）的了解，将能够使配置接近目标定义。

\item
第6章，使用生成器表达式：

生成器表达式在项目中大量使用，力求使这些表达式尽可能简单。项目将包含自定义命令以生成Valgrind和覆盖率报告的文件。此外，还将使用目标钩子，特别是PRE\_BUILD，来清理覆盖率检测过程产生的.gcda文件。

\item
第7章，使用CMake编译C++源代码：

没有C++项目的编译是不可能的。基础知识相当简单，但CMake允许我们以许多方式调整这个过程：扩展目标源代码、配置优化器并提供调试信息。对于这个项目，默认的编译标志就可以了，也研究了一下预处理器：

\begin{itemize}
\item
我们将构建元数据（项目版本、构建时间和Git提交SHA）存储在编译后的可执行文件中并向用户展示。

\item
我们将启用预编译头文件。在如此小的项目中，这并不是真正必要的，但它将帮助我们练习这个概念。
\end{itemize}

不需要Unity构建。

\item
第8章，链接可执行文件和库：

我们将获得默认情况下对项目都有用的链接的一般信息。此外，由于这个项目包含一个库，将明确引用以下特定构建指令：

\begin{itemize}
\item
用于测试和开发的静态库

\item
用于发布的共享库
\end{itemize}

本章还概述了如何隔离main()函数以用于测试目的，我们将采用这种做法。

\item
第9章，管理依赖关系：

为了增强项目的吸引力，将引入一个外部依赖：一个基于文本的用户界面库。第9章探讨了管理依赖关系的各种方法。选择将很简单：FetchContent实用模块通常推荐且最方便。

\item
第10章，使用C++20模块：

尽管我们已经探讨了使用C++20模块，以及支持此功能的环境要求（CMake 3.28，最新编译器），但其广泛支持仍然不足。为了确保项目的可访问性，我们暂时不会引入模块。

\item
第11章：测试框架

实施适当的自动化测试，对于确保解决方案质量随时间保持一致至关重要。我们将集成CTest并组织项目以方便测试，并应用之前提到的main()函数分离方法。

本章将讨论两种测试框架：Catch2和GTest与GMock；我们将使用后者。为了获取覆盖率的详细信息，我们将使用LCOV生成HTML报告。

\item
第12章：程序分析工具

对于静态分析，可以从一系列工具中选择：Clang-Tidy、Cpplint、Cppcheck、include-what-you-use（IWYU）和link-what-you-use（LWYU）。我们将选择Cppcheck，因为Clang-Tidy与使用GCC构建的预编译头文件兼容性较差。

动态分析将使用Valgrind的Memcheck工具，并配合Memcheck-cover包装器来生成HTML报告。此外，在构建过程中，源码将自动通过ClangFormat进行格式化。

\item
第13章：文档生成

提供文档对于我们项目中的库来说是必不可少的。CMake支持使用Doxygen自动化生成文档。我们将采用这种方法，并在设计中加入doxygen-awesome-css主题以更新样式。

\item
第14章：安装与打包

最后，将配置解决方案的安装和打包，并准备文件形成包，包括目标定义。安装这些内容及构建目标产生的工件到合适的目录中，通过包含GNUInstallDirs模块实现。还将配置一些组件以模块化解决方案，并为CPack做好准备。
\end{itemize}

专业的项目通常会附带一些文本文件：README、LICENSE、INSTALL等。我们将在章节末尾简要介绍这些文件。

为了简化流程，不会实现自定义逻辑来检查所有必需的工具和依赖项是否可用。我们将依赖于CMake来显示其诊断信息并告诉用户缺少什么。如果项目获得了重要的关注，可能需要考虑添加这些机制以改善用户体验。

有了清晰的计划后，让我们讨论如何实际地构建项目结构，包括逻辑目标和目录结构。


































