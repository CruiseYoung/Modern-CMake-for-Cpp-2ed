
编译源码后，通常希望避免对同一平台重新编译，或将编译输出与外部项目共享。可以将最初生成的单个对象文件分发出去，但这会带来挑战。分发多个文件，并将它们逐个集成到构建系统中可能很麻烦，特别是在处理大量文件时。更有效的方法是将所有对象文件合并为一个单元以供共享。CMake大大简化了这个任务。可以使用简单的add\_library()命令（与target\_link\_libraries()命令配对）生成这些库。

按照约定，所有库都有一个公共前缀(即lib)，并使用特定于系统的扩展名，来表示它们是什么类型的库：

\begin{itemize}
\item
类Unix系统中，静态库具有.a扩展名，在Windows上为.lib。

\item
某些类Unix系统（如Linux）上，共享库（和模块）具有.so扩展名，而在其他系统（如macOS）上为.dylib。在Windows上，扩展名为.dll。

\item
共享模块通常使用与共享库相同的扩展名，但不总是如此。在macOS上，可以使用.so，特别是当模块是从另一个Unix平台移植过来时。
\end{itemize}

构建库（静态、共享或共享模块）的过程通常称为“链接”，在ch08/01-libraries项目的构建输出中看到：

\begin{shell}
[ 33%] Linking CXX static library libmy_static.a
[ 66%] Linking CXX shared library libmy_shared.so
[100%] Linking CXX shared module libmy_module.so
[100%] Built target module_gui
\end{shell}

然而，前面提到的库并非全部需要使用链接器来创建。对于某些库，该过程可能会跳过某些步骤，如重定位和引用解析。

\mySubsubsection{8.3.1.}{静态库}

静态库本质上是将原始对象文件的集合存储在一起的存档，它们会通过索引来加速链接过程。在类Unix系统中，这样的存档可以通过ar工具创建，并使用ranlib进行索引。

构建过程中，只有静态库中必要的符号，才会导入最终的可执行文件中，优化其大小和内存使用。这种选择性集成确保了可执行文件是自包含的，消除了在运行时对外部文件的需求。

要创建静态库，可以简单地使用前面章节中已经看到的命令：

\begin{shell}
add_library(<name> [<source>...])
\end{shell}

这个简写代码默认会生成一个静态库，如果将BUILD\_SHARED\_LIBS变量设置为ON，会默认生成动态库。如果确定想要构建一个静态库，可以显式提供一个关键字：

\begin{shell}
add_library(<name> STATIC [<source>...])
\end{shell}

使用静态库可能并不总是理想的选择，特别是同一台机器上运行的多个应用程序都使用这些编译的代码时。

\mySubsubsection{8.3.2.}{共享库}

共享库与静态库有显著不同。是使用链接器构建的，链接器完成了链接的两个阶段。这产生了一个包含节头、节和节头表的完整文件，如图8.1所示。

共享库，通常称为共享对象，可以在多个不同的应用程序中同时使用。当第一个程序使用共享库时，操作系统会将该库的一个实例加载到内存中。操作系统会为后续使用该库的程序提供相同的地址，这要归功于复杂的虚拟内存机制。然而，对于每个使用该库的进程，库的.data和.bss段是分别实例化的。这确保了每个进程，都可以调整其变量，而不影响其他进程。

感谢这种方法，系统整体内存使用得到了优化。如果使用主流认可的库，可能不需要将其包含在程序中，它可能已经存在于目标机器上。但若没有预安装，用户需要在运行应用程序之前手动安装。如果安装的库版本与预期版本不同，这可能导致潜在问题，这类问题称为“依赖地狱”。

我们可以通过显式使用SHARED关键字来构建共享库：

\begin{shell}
add_library(<name> SHARED [<source>...])
\end{shell}

由于共享库在程序初始化期间加载到操作系统的内存中，因此执行程序与磁盘上的实际库文件之间没有关联。相反，链接是间接完成的。类Unix系统中，这是通过共享对象名（SONAME）实现的，可以将其理解为库的“逻辑名称”。

这允许在库版本控制上具有灵活性，并确保对库的向后兼容性更改，不会破坏依赖的应用程序。

可以使用生成器表达式，查询产生的SONAME文件的一些路径属性（确保将target替换为目标名称）：

\begin{itemize}
\item
\$<TARGET\_SONAME\_FILE:target> 返回完整路径 (.so.3)。

\item
\$<TARGET\_SONAME\_FILE\_NAME:target> 只返回文件名。

\item
\$<TARGET\_SONAME\_FILE\_DIR:target> 只返回相应文件夹路径。
\end{itemize}

本书后面将介绍的高级场景中非常有用，包括：

\begin{itemize}
\item
打包和安装过程中正确使用生成的库。

\item
编写自定义的CMake规则进行依赖管理。

\item
测试过程中利用SONAME。

\item
构建后命令中复制或重命名生成的库。
\end{itemize}

可能对其他特定于操作系统的工件有类似的需求，CMake提供了两个生成器表达式，提供了与SONAME相同的后缀。对于Windows：

\begin{itemize}
\item
\$<TARGET\_LINKER\_FILE:target>返回与生成的动态链接库（DLL）关联的.lib导入库的完整路径。请注意，.lib扩展名与静态Windows库相同，但应用并不相同。

\item
\$<TARGET\_RUNTIME\_DLLS:target> 返回目标在运行时依赖的DLL列表。

\item
\$<TARGET\_PDB\_FILE:target> 返回.pdb程序数据库文件的完整路径（用于调试）。
\end{itemize}

由于共享库在程序初始化期间加载到操作系统的内存中，因此适用于提前知道程序将使用哪些库的情况。在运行时确定这些的情况又如何呢？

\mySubsubsection{8.3.3.}{共享模块}

共享模块或模块库是共享库的一种变体，设计用于在运行时作为插件加载。与在程序启动时自动加载的标准共享库不同，共享模块仅在程序明确请求时加载。可以通过以下系统调用来完成：

\begin{itemize}
\item
在Windows上使用LoadLibrary

\item
在Linux和macOS上使用dlopen()，然后是dlsym()
\end{itemize}

这种方法的主要原因是节约内存。许多软件应用程序，在整个进程生命周期中都未使用高级功能。每次都将这些功能加载到内存中将非常低效。

或者，提供一种途径，以便通过可以单独销售、交付和加载的专业功能来扩展主程序。

要构建共享模块，需要使用MODULE关键字：

\begin{shell}
add_library(<name> MODULE [<source>...])
\end{shell}

模块设计为与将使用它的可执行文件分开部署，所以不应该尝试将模块与可执行文件链接。

\mySubsubsection{8.3.4.}{位置无关代码（PIC）}

由于使用了虚拟内存，程序本质上是某种程度上位置无关的。这项技术抽象了物理地址。当调用一个函数时，CPU使用内存管理单元（MMU）将虚拟地址（每个进程从0开始）转换为相应的物理地址（在分配时确定）。有趣的是，这些映射并不总是遵循特定的顺序。

编译库引入了不确定性：不清楚哪些进程可能会使用库，或者在虚拟内存中的位置。无法预测符号的地址，或其相对于库的机器代码的位置。为了处理这个问题，需要另一层间接寻址。

PIC将符号（如对函数和全局变量的引用）映射到运行时地址。PIC在二进制文件中引入了一个新的节：全局偏移表（GOT）。链接期间，计算了GOT节相对于.text节（程序代码）的相对位置。所有符号引用将通过一个偏移量指向GOT中的占位符。

当程序加载时，GOT节转换为一个内存段。随着时间的推移，这个段累积了符号的运行时地址。这种方法称为“延迟加载”，确保加载器仅在需要时填充特定的GOT条目。

共享库和模块的所有源代码必须在使用PIC标志激活的情况下编译。通过将POSITION\_INDEPENDENT\_CODE目标属性设置为ON，将告诉CMake适当地添加编译器特定的标志，例如为GCC或Clang添加-fPIC。

这个属性对于共享库是自动启用的。如果共享库依赖于另一个目标，例如静态或对象库，也必须将这个属性应用于依赖目标：

\begin{shell}
set_target_properties(dependency
                      PROPERTIES POSITION_INDEPENDENT_CODE ON)
\end{shell}

因为会检查这个属性的一致性，所以忽略这一步将导致CMake中的冲突。

我们的下一个讨论点转向符号。特别是，探讨名称冲突，这可能导致模糊和定义不一致。











