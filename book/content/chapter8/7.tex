在 CMake 中进行链接可能一开始看起来很简单，但当我们深入挖掘时，会发现其背后大有乾坤。毕竟，链接可执行文件并不像拼图那样简单。当深入研究对象文件和库的结构时，存储各种类型的数据、指令、符号名称等节（section）都需要重新排序。在程序运行之前，这些节需要经过重定位。

解析符号也非常关键。链接器必须对所有翻译单元中的引用进行排序，确保没有遗漏。当这些都处理好了，链接器就会创建程序头部，并将其放入最终的可执行文件中。这个头部为系统加载器提供指令，详细说明如何将合并的节转换为段，这些段将构成进程的运行时内存镜像。我们还讨论了三种类型的库：静态库、共享库和共享模块。探讨了它们的区别，以及在哪些场景下某种库可能比其他库更适合使用。此外，还提到了 PIC —— 一个强大的概念，促进了符号的延迟绑定。

ODR 是 C++ 的一个概念，由链接器强制执行。我们查看了如何在静态库和动态库中处理最基本的符号重复问题。还强调了尽可能使用命名空间的价值，并建议不要过分依赖链接器来避免符号冲突。

对于一个看似简单的步骤（考虑到 CMake 专门用于链接的有限命令），其确实有其复杂性。特别是在处理具有嵌套和循环依赖关系的库时，其中一个比较棘手的问题是链接的顺序。现在我们了解了链接器如何选择最终进入二进制文件的符号，以及如何在需要时覆盖这种行为。

最后，研究了如何利用链接器为测试准备程序 —— 通过将 main() 函数分离到另一个翻译单元。这使我们能够引入另一个可执行文件，该文件针对与生产中将要执行的确切机器代码运行测试。

凭借对链接的新知识，已准备好将外部库引入 CMake 项目。下一章中，将探讨如何在 CMake 中管理依赖项。