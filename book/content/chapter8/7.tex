在 CMake 中进行链接可能一开始看起来很简单，但当我们深入挖掘时，会发现其背后大有乾坤。毕竟，链接可执行文件并不像拼图那样简单。当我们深入研究对象文件和库的结构时，很明显，存储各种类型的数据、指令、符号名称等的节（section）需要重新排序。在程序可运行之前，这些节需要经过所谓的重定位过程。

解析符号也非常关键。链接器必须对所有翻译单元中的引用进行排序，确保没有遗漏。一旦这些都处理好了，链接器就会创建程序头部并将其放入最终的可执行文件中。这个头部为系统加载器提供指令，详细说明如何将合并的节转换为段，这些段将构成进程的运行时内存镜像。我们还讨论了三种类型的库：静态库、共享库和共享模块。我们探讨了它们的区别以及在哪些场景下某种库可能比其他库更适合使用。此外，我们还提到了 PIC —— 一个强大的概念，它促进了符号的延迟绑定。

ODR 是 C++ 的一个概念，但正如我们所见，它是由链接器强制执行的。我们查看了如何在静态库和动态库中处理最基本的符号重复问题。我们还强调了尽可能使用命名空间的价值，并建议不要过分依赖链接器来防止符号冲突。

对于一个看似简单的步骤（考虑到 CMake 专门用于链接的有限命令），它确实有其复杂性。其中一个比较棘手的问题是链接的顺序，特别是在处理具有嵌套和循环依赖关系的库时。现在我们了解了链接器如何选择最终进入二进制文件的符号，以及如何在需要时覆盖这种行为。

最后，我们研究了如何利用链接器为测试准备我们的程序 —— 通过将 main() 函数分离到另一个翻译单元。这使我们能够引入另一个可执行文件，该文件针对与生产中将要执行的确切机器代码运行测试。

凭借我们对链接的新知识，我们已准备好将外部库引入我们的 CMake 项目。在下一章中，我们将探讨如何在 CMake 中管理依赖项。