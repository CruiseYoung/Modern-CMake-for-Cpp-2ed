在第七章《使用 CMake 编译 C++ 源代码》中，我们讨论了 C++ 程序的生命周期，它由五个主要阶段组成——编写、编译、链接、加载和执行。正确编译所有源代码后，我们需要将它们组合成一个可执行文件。我们说过，编译产生的对象文件不能直接由处理器执行。但为什么是这样呢？

为了回答这个问题，让我们了解对象文件是广泛使用的可执行和链接格式（ELF）的一种变体，这在类 Unix 系统和其他许多系统中都很常见。像 Windows 或 macOS 这样的系统有自己的格式，但我们将专注于 ELF 来解释这个原理。图 8.1 显示了编译器如何构建这些文件的结构：

\myGraphic{0.9}{content/chapter8/images/1.png}{图 8.1：对象文件的结构}

编译器将为每个翻译单元（每个 .cpp 文件）准备一个对象文件。这些文件将用于构建我们程序的内存映像。对象文件包含以下内容：

\begin{itemize}
\item
一个 ELF 头部，它标识目标操作系统（OS）、文件类型、目标指令集架构，以及 ELF 文件中两个头部表的位置和大小的详细信息：程序头部表（在对象文件中不存在）和节头部表。

\item
按类型分组信息的二进制节。

\item
一个节头部表，包含关于名称、类型、标志、内存中的目标地址、文件中的偏移量以及其他杂项信息。它用于了解这个文件中有哪些节以及它们的位置，就像目录一样。
\end{itemize}

当编译器处理源代码时，它将收集的信息分类到不同的节中。这些节构成了 ELF 文件的核心，位于 ELF 头部和节头部之间。以下是一些这样的节的例子：

\begin{itemize}
\item
.text 节包含所有指定给处理器执行的机器代码指令。

\item
.data 节保存初始化的全局和静态变量的值。

\item
.bss 节为未初始化的全局和静态变量保留空间，这些变量在程序开始时初始化为零。

\item
.rodata 节保存常量的值，使其成为一个只读数据段。

\item
.strtab 节是一个字符串表，包含常量字符串，例如来自基本 hello.cpp 示例的“Hello World”。

\item
.shstrtab 节是一个字符串表，保存所有其他节的名字。
\end{itemize}

这些节紧密地反映了最终放入 RAM 运行我们应用程序的可执行文件的版本。然而，我们不能简单地将对象文件连接在一起，然后将结果文件加载到内存中。不加考虑的合并会导致一系列复杂问题。例如，我们会浪费空间和时间，消耗过多的 RAM 页面。将指令和数据传输到 CPU 缓存也会变得笨拙。整个系统将不得不处理增加的复杂性，浪费宝贵的周期，在执行过程中在无数的 .text、.data 和其他节之间跳转。

我们将采取更有组织的方法：每个对象文件的节将与其他对象文件中相同类型的节组合在一起。这个过程称为重定位，这就是为什么对象文件的 ELF 文件类型被标记为“可重定位”。但重定位不仅仅是组装匹配的节。它还涉及更新文件内的内部引用，例如变量、函数、符号表索引和字符串表索引的地址。每个这些值都是其自身对象文件的本地值，从零开始编号。因此，在合并文件时，必须调整这些值以确保它们引用合并文件中的正确地址。

图 8.2 显示了重定位的操作过程 —— .text 节已经重定位，.data 节正在从所有链接的文件中组装，.rodata 和 .strtab 节将遵循相同的流程（为了简单起见，图中不包含头部）：

\myGraphic{0.9}{content/chapter8/images/2.png}{图 8.2：.data 节的重定位}

接下来，链接器需要解析引用。当一个翻译单元的代码引用另一个单元中定义的符号时，无论是通过包含其头文件还是使用 extern 关键字，编译器都会承认这个声明，假设稍后会提供定义。链接器的主要角色是收集这些未解决的外部符号引用，然后识别并在合并的可执行文件中填充它们所属的地址。图 8.3 显示了这个引用解析过程的简单示例：

\myGraphic{0.9}{content/chapter8/images/3.png}{图 8.3：引用解析}

如果程序员不了解这是如何工作的，这部分链接可能会成为问题的来源。我们可能会得到无法找到其对应外部符号的未解决引用。或者相反：我们提供了太多的定义，而链接器不知道选择哪一个。

最终的可执行文件与对象文件非常相似，因为它包含了解决引用的重定位节、节头部表，当然还有描述整个文件的 ELF 头部。主要的区别在于存在程序头部，如下图所示：

\myGraphic{0.9}{content/chapter8/images/4.png}{图 8.4：ELF 中可执行文件的结构}

程序头部位于 ELF 头部之后。操作系统的加载器将读取这个程序头部来设置程序，配置内存布局，并创建进程映像。程序头部中的条目指定哪些节将被复制，按照什么顺序，以及复制到虚拟内存中的哪些地址。它们还包含关于它们的访问控制标志（读、写或执行）的信息，以及一些其他有用的细节。创建的进程中的每个命名节将由一个内存片段表示；这样的片段称为段。

对象文件也可以打包在库中，库是一个中间产品，可以用于最终的可执行文件或另一个库。

现在我们了解了链接的工作原理，让我们继续下一部分，在那里我们将讨论三种不同类型的库。
























































