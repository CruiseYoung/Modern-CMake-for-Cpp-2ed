
Variables in CMake are a surprisingly complex subject. Not only are there three categories of variables – normal, cache, and environment – but they also reside in different variable scopes, with specific rules on how one scope affects the other. Very often, a poor understanding of these rules becomes a source of bugs and headaches. I recommend you study this section with care and make sure you understand all of the concepts before moving on.

Let’s start with some key facts about variables in CMake:

\begin{itemize}
\item
Variable names are case-sensitive and can include almost any character.

\item
All variables are stored internally as strings, even if some commands can interpret them as values of other data types (even lists!).
\end{itemize}

The basic variable manipulation commands are set() and unset(), but there are other commands that can alter variable values, such as string() and list().

To declare a normal variable, we simply call set(), providing its name and the value:

\filename{ch02/02-variables/set.cmake}

\begin{cmake}
set(MyString1 "Text1")
set([[My String2]] "Text2")
set("My String 3" "Text3")
message(${MyString1})
message(${My\ String2})
message(${My\ String\ 3})
\end{cmake}

As you can see, the use of brackets and quoted arguments allows for spaces to be included in the variable name. However, when referencing it later, we have to escape the whitespace with a backslash, $ \verb|\|$. For that reason, it is recommended to use only alphanumeric characters, dashes (-), and underscores (\_) in variable names.

Also avoid reserved names (in uppercase, lowercase, or mixed case) that begin with any of the following: CMAKE\_, \_CMAKE\_, or an underscore, \_, followed by the name of any CMake command.

To unset a variable, we can use unset() in the following way: unset(MyString1).

\begin{myNotic}{Note}
The set() command accepts a plain text variable name as its first argument, but the message() command uses a variable reference wrapped in the \$\{\} syntax.
\end{myNotic}

What would happen if we were to provide a variable wrapped in the \$\{\} syntax to the set() command?

To answer that, we’ll need to understand variable references better.

\mySubsubsection{2.2.1}{Variable references}

I already mentioned references briefly in the Command arguments section, as they’re evaluated for quoted and unquoted arguments. We learned that to create a reference to a defined variable, we need to use the \$\{\} syntax, like so: message(\$\{MyString1\}).

On evaluation, CMake will traverse the variable scopes from the innermost scope to the outermost scope and replace \$\{MyString1\} with a value, or an empty string if no variable is found (CMake won’t produce any error messages). This process is also called variable evaluation, expansion, or interpolation.

Interpolation is performed in an inside-out manner, beginning from the innermost curly brace pair and moving outward. For example, if the \$\{MyOuter\$\{MyInner\}\} reference is encountered:

\begin{enumerate}
\item
CMake will try to evaluate MyInner first, rather than searching for a variable named MyOuter\$\{MyInner\}.

\item
If the MyInner variable is successfully expanded, CMake will repeat the expansion process using the newly formed reference until no further expansion is possible.
\end{enumerate}

To avoid receiving unexpected outcomes, it is recommended to refrain from storing variable expansion tokens in variable values.

CMake will perform variable expansion to the full extent, and only after completion will it pass the resulting values as arguments to the command. This is why when we call set(\$\{MyInner\} "Hi"); we won’t actually be changing the MyInner variable, but instead, we’ll change the variable named after the value stored in MyInner. Very often, this is not what we want.

Variable references are a bit peculiar in how they work when it comes to variable categories, but in general, the following applies:

\begin{itemize}
\item
The \$\{\} syntax is used to reference normal or cache variables.

\item
The \$ENV\{\} syntax is used to reference environment variables.

\item
The \$CACHE\{\} syntax is used to reference cache variables.
\end{itemize}

That’s right, with \$\{\}, you might get a value from one category or the other: the normal variable will be used if it was set in the current scope, but if it wasn’t set, or was unset, CMake will use the cache variable with the same name. If there’s no such variable, the reference evaluates to an empty string.

CMake predefines a lot of built-in normal variables that serve different purposes. For example, you can pass command-line arguments to scripts after the -{}- token and they will be stored in the CMAKE\_ARGV<n> variables (the CMAKE\_ARGC variable will contain the count).

Let’s introduce other categories of variables so that we understand clearly what they are.

\mySubsubsection{2.2.2}{Using environment variables}

This is the least complicated kind of variable. CMake makes a copy of the variables that were in the environment used to start the cmake process and makes them available in a single, global scope. To reference these variables, use the \$ENV\{<name>\} syntax.

CMake changes these variables, but changes will only be made to a local copy in the running cmake process and not the actual system environment; moreover, these changes won’t be visible to subsequent runs of builds or tests, so it is not recommended.

Be aware that there are a few environment variables that affect different aspects of CMake behavior. For example, the CXX variable specifies what executable will be used for compiling C++ files. We’ll cover environment variables, as they will become relevant to this book. A full list is available in the documentation: \url{https://cmake.org/cmake/help/latest/manual/cmake-envvariables.7.html}.

\begin{myNotic}{Note}
It’s important to realize that if you use ENV variables as arguments to your commands, the values will be interpolated during the generation of the buildsystem. This means that they will get permanently baked into the build tree, and changing the environment for the build stage won’t have any effect.
\end{myNotic}

For example, take the following project file:

\filename{ch02/03-environment/CMakeLists.txt}

\begin{cmake}
cmake_minimum_required(VERSION 3.20.0)
project(Environment)
message("generated with " $ENV{myenv})
add_custom_target(EchoEnv ALL COMMAND echo "myenv in build
  is" $ENV{myenv})
\end{cmake}

The preceding example has two steps: it will print the myenv environment variable during the configuration, and it will add a build stage through add\_custom\_target(), which echoes the same variable as part of the build process. We can test what happens with a bash script that uses one value for the configuration stage and another for the build stage:

\filename{ch02/03-environment/build.sh}

\begin{shell}
#!/bin/bash
export myenv=first
echo myenv is now $myenv
cmake -B build .
cd build
export myenv=second
echo myenv is now $myenv
cmake --build .
\end{shell}

Running the preceding code clearly shows that the value set during the configuration is persisted to the generated buildsystem:

\begin{shell}
$ ./build.sh | grep -v "\-\-"
myenv is now first
generated with first
myenv is now second
Scanning dependencies of target EchoEnv
myenv in build is first
Built target EchoEnv
\end{shell}

This concludes our discussion on environmental variables for the time being. Let us now move on to the final category of variables: cache variables.

\mySubsubsection{2.2.3}{Using cache variables}

We first mentioned cache variables when discussing command-line options for cmake in Chapter 1, First Steps with CMake. Essentially, they’re persistent variables stored in a CMakeCache.txt file in your build tree. They contain information gathered during the configuration stage of your project. They originate from the system (path to compilers, linkers, tools, and others) and from the user, provided through the GUI or from the command line with the -D option. Again, cache variables are not available in scripts; they only exist in projects.

Cache variables will be used if the \$\{<name>\} reference can’t find a normal variable defined in the current scope but a cache variable with the same name exists. However, they can also be explicitly referenced with the \$CACHE\{<name>\} syntax and defined with a special form of the set() command:

\begin{cmake}
set(<variable> <value> CACHE <type> <docstring> [FORCE])
\end{cmake}

In contrast to the set() command for normal variables, extra arguments are necessary for cache variables: <type> and <docstring>. This is because these variables can be configured by the user, and the GUI requires this information to display them appropriately.

The following types are accepted:

\begin{itemize}
\item
BOOL: A Boolean on/off value. The GUI will show a checkbox.

\item
FILEPATH: A path to a file on a disk. The GUI will open a file dialog.

\item
PATH: A path to a directory on a disk. The GUI will open a directory dialog.

\item
STRING: A line of text. The GUI offers a text field to be filled. It can be replaced by a dropdown control by calling set\_property(CACHE <variable> STRINGS <values>).

\item
INTERNAL: A line of text. The GUI skips internal entries. The internal entries may be used to store variables persistently across runs. Use of this type implicitly adds the FORCE keyword.
\end{itemize}

The <doctring> value is simply a label that will be displayed by the GUI next to the field to provide more detail about this setting to the user. It is required even for an INTERNAL type.

Setting cache variables in the code follows the same rules as environmental variables to some extent – values are overwritten only for the current execution of CMake. However, if the variable doesn’t exist in the cache file or an optional FORCE argument is specified, the value will be persisted:

\begin{cmake}
set(FOO "BAR" CACHE STRING "interesting value" FORCE)
\end{cmake}

Similar to C++, CMake supports variable scopes, albeit implemented in a rather specific way.

\mySubsubsection{2.2.4}{How to correctly use variable scopes in CMake}

Variable scope is probably the strangest concept in the CMake language. This is maybe because we’re so accustomed to how it is implemented in general-purpose languages. We’re explaining this early because incorrect understanding of scopes is often a source of bugs that are difficult to find and fix.

Just to clarify, variable scope as a general concept is meant to separate different layers of abstraction expressed with code. Scopes are nested inside one another in a tree-like fashion. The outermost scope (root) is called the global scope. Any scope can be called the local scope, to indicate the currently executed or discussed scope. Scopes create boundaries between variables, so that the nested scope can access variables defined in the outer scope, but not the other way around.

CMake has two kinds of variable scopes:

\begin{itemize}
\item
File: Used when blocks and custom functions are executed within a file

\item
Directory: Used when the add\_subdirectory() command is called to execute another CMakeLists.txt listfile in a nested directory
\end{itemize}

\begin{myNotic}{Note}
Conditional blocks, loop blocks, and macros don’t create separate scopes.
\end{myNotic}

So, what’s so different about how a variable scope is implemented in CMake? When a nested scope is created, CMake simply fills it with copies of all the variables from the outer scope. Subsequent commands will affect these copies. But as soon as the execution of the nested scope is completed, all copies are deleted and the original variables from the outer scope are restored.

How the concept of scope works in CMake has interesting implications that aren’t that common in other languages. When executing in a nested scope, if you unset (unset()) a variable created in the outer scope, it will disappear, but only in the current nested scope, because the variable is a local copy. If you now reference this variable, CMake will determine that no such variable is defined, it will ignore the outer scopes, and continue searching through the cache variables (which are considered separate). That’s a possible gotcha.

File variable scopes are opened using the block()and function()commands (but not macro()) and closed with the endblock() and endfunction() commands, respectively. We’ll cover functions in the Command definitions section of this chapter. For now, let’s see how variable scope works in practice with the simpler block() command (introduced in CMake 3.25).

Consider the following example:

\filename{ch02/04-scope/scope.cmake}

\begin{cmake}
cmake_minimum_required(VERSION 3.26)

set(V 1)
message("> Global: ${V}")
block() # outer block
  message(" > Outer: ${V}")
  set(V 2)
  block() # inner block
    message(" > Inner: ${V}")
    set(V 3)
    message(" < Inner: ${V}")
  endblock()
  message(" < Outer: ${V}")
endblock()
message("< Global: ${V}")
\end{cmake}

We initially set the variable V to 1 in the global scope. After entering the outer and inner blocks, we immediately change them to 2 and 3, respectively. We also print the variable upon entering and exiting each scope:

\begin{shell}
> Global: 1
  > Outer: 1
    > Inner: 2
    < Inner: 3
  < Outer: 2
< Global: 1
\end{shell}

As explained previously, as we enter each nested scope, the variable values are temporarily copied from the outer scope but their original values are restored upon exiting. This is reflected in the last two lines of the output.

The block() command can also propagate values to outer scopes (like C++ would do by default), but it has to be explicitly enabled with the PROPAGATE keyword. If we were to enable propagation for the inner block with block(PROPAGATE V), the output would be as follows:

\begin{shell}
> Global: 1
  > Outer: 1
    > Inner: 2
    < Inner: 3
  < Outer: 3
< Global: 1
\end{shell}

Again, we affected the scope of the outer block but not the global scope.

Another method for modifying a variable in the outer scope is to set the PARENT\_SCOPE flag for the set() and unset() commands:

\begin{cmake}
set(MyVariable "New Value" PARENT_SCOPE)
unset(MyVariable PARENT_SCOPE)
\end{cmake}

That workaround is a bit limited, as it doesn’t allow accessing variables more than one level up. Another thing worth noting is the fact that using PARENT\_SCOPE doesn’t change variables in the current scope.

Now that we know how to handle basic variables, let’s take a look at one special case: since all variables are stored as strings, CMake has to take a more creative approach to more complex data structures such as lists.











































