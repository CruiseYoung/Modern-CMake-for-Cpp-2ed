This chapter opened the door to actual programming with CMake – you’re now able to write great, informative comments and utilize built-in commands, and you understand how to correctly provide all kinds of arguments to them. This knowledge alone will help you understand the unusual syntax of CMake listfiles that you might have seen in projects created by others. We have covered variables in CMake – specifically, how to reference, set, and unset normal, cache, and environment variables. We delved into how file and directory variable scopes work, how to create them, and what issues we might encounter and how to solve them. We also covered lists and control structures. We examined the syntax of conditions, their logical operations, the evaluation of unquoted arguments, as well as strings and variables. We learned how to compare values, do simple checks, and examine the state of the files in the system. This allows us to write conditional blocks and while loops; while we were talking about loops, we also grasped the syntax of foreach loops.'

Understanding how to define custom commands using macro and function statements will undoubtedly facilitate cleaner, more procedural code. We also discussed strategies for improving code structure and creating more readable names.

Finally, we formally introduced the message() command and its multiple log levels. We also studied how to partition and include listfiles, and we discovered a few other useful commands. With this information, we are well prepared to take on the next chapter, Chapter 3, Using CMake in Popular IDEs.