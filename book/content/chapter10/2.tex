我想在三年前写关于如何使用C++模块。尽管模块已经被接受为C++20规范的一部分，但C++生态系统的支持仍然远远没有准备好使用这个特性。幸运的是，自从本书的第一版以来，很多事情都发生了变化，随着CMake 3.28的发布，C++20模块得到了正式支持（尽管从3.26版本开始就已经有了实验性支持）。

三年似乎实现一个特性是很长的时间，但我们必须要记住，这不只是取决于CMake。许多拼图碎片必须汇集在一起并良好工作。首先，我们需要编译器理解如何处理模块，然后构建系统如GNU Make或Ninja必须能够与模块一起工作，只有这样CMake才能使用这些新机制来提供对模块的支持。

这告诉我们一件事情：并不是每个人都会有最新的兼容工具，即使是现在，当前的支持仍然处于早期阶段。这些限制使得模块不适合广泛的受众。所以也许不要急于依赖它们来构建生产级别的项目。

尽管如此，如果你是尖端解决方案的爱好者，那么你将会得到一次享受！如果你可以严格控制项目的构建环境，例如，使用专用机器或构建容器化（Docker等），你可以在内部有效地使用模块。只需小心行事，并理解你的里程可能会有所不同。可能会有一个时刻，你会因为任何一个工具中的缺失或错误实现的特性而完全放弃模块。

在C++构建的上下文中，“模块”是一个非常重的词。我们之前在本书中讨论过CMake的模块：find模块、工具模块等。为了澄清，C++模块与CMake模块无关。相反，它们是C++20版本中添加的语言的原生特性。

在其核心，一个C++模块是一个单一源文件，它将头文件和实现文件的功能封装成一个连贯的代码单元。它包括两个主要部分：

\begin{itemize}
\item
二进制模块接口（BMI）类似于头文件的目的，但它是二进制格式，当被其他翻译单元使用时，显著减少了重新编译的需求。

\item
模块实现单元提供模块的实现、定义和内部细节。其内容不能从模块外部直接访问，有效地封装了实现细节。
\end{itemize}

引入模块是为了减少编译时间和解决预处理器和传统头文件的一些问题。让我们看看在典型的传统项目中，多个翻译单元是如何粘合在一起的。

\myGraphic{0.3}{content/chapter10/images/1.png}{图10.1：使用传统头文件的项目结构}

前面的图显示了预处理器如何遍历项目树来构建程序。正如我们在第7章“使用CMake编译C++源代码”中学到的，为了构建每个翻译单元，预处理器机械地将文件拼接在一起。这意味着生成一个包含所有由预处理器指令包含的头文件的的长文件。这样，main.cpp将首先包含它自己的源代码，然后是lib.h、a.h、1.h和2.h的内容。只有然后编译器才会启动并开始解析每一个字符以生成二进制目标文件。这样做本身并没有错，直到我们意识到为了编译lib.cpp，main.cpp中包含的头文件必须重新编译。并且这种冗余会随着每个翻译单元的添加而增加。

传统头文件还有其他复杂问题：

\begin{itemize}
\item
需要包含保护，忘记时会导致问题。

\item
循环引用的符号需要前置声明。

\item
对头文件进行小的更改需要重新编译所有翻译单元。

\item
预处理器宏可能难以调试和维护。
\end{itemize}

模块立即解决了其中的许多问题，但一些问题仍然相关：模块与头文件一样，可以相互依赖。当一个模块导入另一个模块时，我们仍然需要按照正确的顺序编译它们，从最内层的模块开始。这通常不是一个大问题，因为模块的尺寸往往要大得多。在许多情况下，整个库可以存储在单个模块中。

让我们看看模块在实际中是如何编写和使用的。在这个简单的例子中，我们将只返回两个参数的和：

\filename{ch10/01-cxx-modules/math.cppm}

\begin{cpp}
export module math;
export int add(int a, int b) {
    return a + b;
}
\end{cpp}

这样一个模块是不言自明的：我们从一条语句开始，告诉程序的其余部分这确实是一个名为math的模块。然后我们跟随一个用export关键字指定为可以从模块外部访问的常规函数定义。

\begin{myNotic}{Note}
你会注意到模块文件的扩展名与常规C++源代码的不同。这是一个约定俗成的问题，不应影响代码的处理方式。我的建议是基于你将使用的工具链来选择：

\begin{itemize}
\item
.ixx是MSVC的扩展。

\item
.cppm是Clang的扩展。

\item
.cxx是GCC的扩展。
\end{itemize}
\end{myNotic}

要使用这个模块，我们需要在程序中导入它：

\filename{ch10/01-cxx-modules/main�cpp}

\begin{cpp}
import math;

#include <iostream>

int main() {
    std::cout << "Addition 2 + 2 = " << add(2, 2) << std::endl;
    return 0;
}
\end{cpp}

导入math语句足以将模块中导出的符号直接引入主程序。我们现在可以在main()函数的主体中使用add()函数。从表面上看，模块与头文件非常相似。但是，如果我们尝试像往常一样编写CMake列表文件，我们将无法成功地构建项目。是时候介绍使用C++模块的必要步骤了。









