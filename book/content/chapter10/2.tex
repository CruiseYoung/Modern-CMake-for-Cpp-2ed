三年前有写过关于如何使用C++模块文章，尽管模块已经为C++20规范的一部分，但C++生态系统的支持仍然没有准备好适配这个特性。幸运的是，自从本书的第一版以来，很多事情都发生了变化，随着CMake 3.28的发布，C++20模块得到了正式支持（尽管从3.26版本开始就已经有了实验性支持）。

三年似乎实现一个特性是很长的时间，但必须要记住，这不只是取决于CMake。许多碎片必须汇集在一起并良好工作。首先，需要编译器理解如何处理模块，然后构建系统如GNU Make或Ninja必须能够与模块一起工作，只有这样CMake才能使用这些新机制来提供对模块的支持。

这说明，并不是每个人都会使用最新的兼容工具，即使是现在，当前的支持仍然处于早期阶段。这些限制使得模块不适合大多数人们。所以也许不要急于依赖它们，来构建生产级别的项目。

尽管如此，如果你是尖端解决方案的爱好者，那么将会得到一次享受！如果可以严格控制项目的构建环境，例如：使用专用机器或构建容器化（Docker等），可以在内部使用模块。只需小心行事，并理解该方式可能会有所不同。可能会有一个时刻，会因为一个工具的缺失或对特性的错误实现，而完全放弃模块。

C++构建的上下文中，“模块”是一个非常重的词。我们之前在本书中讨论过CMake的模块：find模块、工具模块等。而C++模块与CMake模块无关，它是C++20版本中添加的语言的原生特性。

在其核心，一个C++模块是个单一源文件，将头文件和实现文件的功能封装成一个连贯的代码单元。其包括两个主要部分：

\begin{itemize}
\item
二进制模块接口（BMI）类似于头文件的目的，但它是二进制格式，当其他翻译单元使用时，会减少了重新编译的需求。

\item
模块实现单元提供模块的实现、定义和内部细节。其内容不能从模块外部直接访问，有效地封装了实现细节。
\end{itemize}

引入模块是为了减少编译时间，解决预处理器和传统头文件的一些问题。来看看在典型的传统项目中，多个翻译单元如何粘合在一起。

\myGraphic{0.7}{content/chapter10/images/1.png}{图10.1：使用传统头文件的项目结构}

前面的图显示了预处理器如何遍历项目树来构建程序。正如第7章中，为了构建每个翻译单元，预处理器机械地将文件拼接在一起，所以会生成一个包含所有由预处理器展开(包含的头文件)的长文件。这样，main.cpp将先包含自己的源码，然后是lib.h、a.h、1.h和2.h的内容。只有然后编译器才会启动并开始解析每一个字符以生成二进制目标文件。这样做本身并没有错，直到我们意识到为了编译lib.cpp，main.cpp中包含的头文件必须重新编译。并且这种冗余会随着每个翻译单元的添加而增加。

传统头文件还有其他问题：

\begin{itemize}
\item
需要包含保护，忘记时会导致问题。

\item
循环引用的符号需要前置声明。

\item
对头文件进行小的更改，需要重新编译所有翻译单元。

\item
预处理器宏可能难以调试和维护。
\end{itemize}

模块解决了其中的许多问题，但一些问题仍然相关：模块与头文件一样，可以相互依赖。当一个模块导入另一个模块时，仍然需要按照正确的顺序编译它们，从最内层的模块开始。因为模块的尺寸往往要大得多，所以这通常不是一个大问题。许多情况下，整个库可以存储在单个模块中。

来看看模块在实际中如何编写和使用。这个简单的例子中，我们只返回两个参数的和：

\filename{ch10/01-cxx-modules/math.cppm}

\begin{cpp}
export module math;
export int add(int a, int b) {
    return a + b;
}
\end{cpp}

一条语句开始，就告诉程序的其余部分这确实是一个名为math的模块。然后跟着一个用export关键字指定为，可以从模块外部访问的常规函数定义。

\begin{myNotic}{Note}
模块文件的扩展名与常规C++源代码的不同。这是一个约定俗成的问题，不应影响代码的处理方式。最好是基于将使用的工具链来选择扩展名：

\begin{itemize}
\item
.ixx是MSVC的扩展名。

\item
.cppm是Clang的扩展名。

\item
.cxx是GCC的扩展名。
\end{itemize}
\end{myNotic}

要使用这个模块，需要在程序中导入：

\filename{ch10/01-cxx-modules/main�cpp}

\begin{cpp}
import math;

#include <iostream>

int main() {
    std::cout << "Addition 2 + 2 = " << add(2, 2) << std::endl;
    return 0;
}
\end{cpp}

导入math语句足以将模块中导出的符号，直接引入主程序。现在可以在main()函数的主体中使用add()函数。从表面上看，模块与头文件非常相似。但是，若尝试像往常一样编写CMake列表文件，将无法成功地构建项目。那么，是时候介绍使用C++模块的必要步骤了。









