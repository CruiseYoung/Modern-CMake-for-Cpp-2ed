C++20 introduces a new feature to the language: modules. They replace the plain-text symbol declarations in header files with a module file that will be precompiled to an intermediary binary format, greatly reducing the build time.

We will discuss the most essential topics for C++20 modules in CMake, starting with a general introduction to C++20 modules as a concept: their advantages over standard header files and how they simplify the management of units in source code. Although the promise of streamlining the build process is exciting, this chapter highlights how difficult and long the road to their adoption is.

With the theory out of the way, we’ll move on to the practical aspects of implementing the modules in our projects: we’ll discuss enabling their experimental support in earlier versions of CMake, and the full release in CMake 3.28.

Our journey through C++20 modules is not just about understanding a new feature—it’s about rethinking how components interact in large C++ projects. By the end of this chapter, you’ll not only grasp the theoretical aspects of modules but also gain practical insights through examples, enhancing your ability to leverage this feature for better project outcomes.

In this chapter, we’re going to cover the following main topics:

\begin{itemize}
\item
What are the C++20 modules?

\item
Writing projects with C++20 module support

\item
Configuring the toolchain
\end{itemize}

\begin{myNotic}{Note}
This chapter has different technical requirements than others. Make sure you read the next section thoroughly.
\end{myNotic}














