Producing high-quality code is not an easy task, even for highly experienced developers. By including tests in our solution, we lower the chance of making basic mistakes in the main code. But that won’t be enough to avoid more intricate problems. Every piece of software consists of so many details that keeping track of them all becomes a full-time job. Various conventions and specific design practices are established by teams responsible for maintaining the product.

Some questions relate to consistent coding style: should we use 80 or 120 columns in our code? Should we allow std::bind or stick to lambda functions? Is it acceptable to use C-style arrays? Should small functions be written in a single line? Should we always use auto, or only when it improves readability? Ideally, we should steer clear of statements known to be generally incorrect: infinite loops, the use of identifiers reserved by a standard library, unintended data loss, unnecessary if statements, and anything else that is not a “best practice” (see the Further reading section for more information).

Another aspect to consider is code modernization. As C++ evolves, it introduces new features. Keeping track of all the spots where we can update to the latest standard can be challenging. Moreover, doing this manually takes time and increases the risk of introducing errors, especially in a large code base. Finally, we should check how things operate when set into motion: running the program and checking its memory. Is the memory properly released after use? Are we accessing data that was correctly initialized? Or does the code attempt to access non-existent pointers?

Managing all these challenges and questions manually is both time-consuming and prone to errors. Fortunately, we can use automated tools to inspect and enforce rules, correct mistakes, and bring our code up to date. It’s time to explore tools for program analysis. Our code will be scrutinized during every build to make sure it meets industry standards.

In this chapter, we’re going to cover the following main topics:

\begin{itemize}
\item
Enforcing formatting

\item
Using static checkers

\item
Dynamic analysis with Valgrind
\end{itemize}