“You’ll spend more time reading code than writing it, so optimize for readability over writability.” This principle is often echoed in various books on clean code. It’s supported by the experiences of many software developers, which is why even small details like the number of spaces, newlines, and the order of \#import statements are standardized. This standardization isn’t just for the sake of being meticulous; it’s about saving time. Following the practices in this chapter, you can forget about manually formatting code. It gets automatically formatted when you build, a step you’d do anyway to test the code. With ClangFormat, you can make sure the formatting is up to the standard of your choosing.

Going beyond simple whitespace adjustments, code should also meet numerous other guidelines. That’s where clang-tidy comes in. It helps enforce coding that your team or organization agreed on. We discussed this static checker in depth and also touched on other options like Cpplint, Cppcheck, include-what-you-use, and Link What You Use. Since static linkers are relatively fast, we can add them to our builds with little investment, and it will usually be well worth the price.

We also examined Valgrind utilities, focusing on Memcheck to identify issues with memory management, such as incorrect reads and writes. This tool is invaluable for avoiding hours of manual debugging and keeping bugs out of a production environment. We introduced a way to make Valgrind's output more user-friendly with Memcheck-Cover, an HTML report generator. This is especially useful in environments where running an IDE is not possible, like CI pipelines.

This chapter is just a starting point. Many other tools, both free and commercial, are available to help you with code quality. Explore them to find what suits you best. In the next chapter, we’ll dive into generating documentation.