

随着项目的增长，要在项目列表文件和源码中找到所需内容变得越来越困难。因此，项目保持整洁就非常重要。

当需要交付一些重要且时间紧迫的更改，但这些更改不适合项目中的任一目录。现在，需要推送一个清理提交来重新组织文件结构，以便更改可以融入。或者更糟，决定随意放置，并添加一个TODO，以后再处理这个问题。

这些问题累积起来，随着技术债务的增加，维护代码的成本也随之上升。当实时系统出现严重故障需要快速修复，或者不熟悉代码库的人需要引入更改时，这种情况会变得非常棘手。

因此，需要一个好的项目结构。但这意味着什么呢？可以从软件开发的其他领域，如系统设计，借鉴一些规则。项目应该具有以下特点：

\begin{itemize}
\item
易于查找和扩展

\item
边界清晰（项目特定文件应包含在项目目录中）

\item
单个目标遵循层次树结构
\end{itemize}

没有一个确定的解决方案，但在网上可用的各种项目结构模板中，我建议使用以下这个简单且可扩展的模板：

\myGraphic{0.7}{content/chapter4/images/1.png}{图4.1：项目结构的一个示例}

此项目为以下组件定义了目录：

\begin{itemize}
\item
cmake:共享宏和函数，find\_modules 和一次性脚本

\item
src: 二进制库文件，以及源文件和头文件

\item
test: 测试源码
\end{itemize}

此结构中，CMakeLists.txt文件应存在于以下目录中：顶层项目目录、test和src及其所有子目录。主列表文件不应自行声明构建步骤，而应配置项目的一般方面，并通过add\_subdirectory()命令将构建责任委托给嵌套的列表文件。如有需要，这些列表文件可以进一步将工作委托给更深的层次。

\begin{myNotic}{Note}
一些开发者建议将可执行文件与库分开，并创建两个顶级目录而不是一个：src和lib。CMake对这两种工件的处理方式相同，在这个层次上的分离并不重要。
\end{myNotic}

对于较大的项目，src目录中有多个子目录会非常方便。但若只构建一个可执行文件或库，就可以省略，直接在src中存储源文件。无论如何，记得在那里添加一个CMakeLists.txt文件，并执行嵌套的列表文件。一个简单目标的文件树如下所示：

\myGraphic{0.7}{content/chapter4/images/2.png}{图4.2：可执行文件的目录结构}

图4.1中，可以看到src目录根目录下有一个CMakeLists.txt文件——将配置关键的项目设置，并包含来自嵌套目录的所有列表文件。app1目录（如图4.2所示）包含另一个CMakeLists.txt文件，以及.cpp实现文件：class\_a.cpp和class\_b.cpp。还有一个main.cpp文件，其中包含可执行文件的入口。

CMakeLists.txt文件应定义一个目标，使用这些源文件构建一个可执行文件——我们将在下一章学习如何做到这一点。

头文件放置在include目录中，可以用来为其他C++翻译单元声明符号。接下来，有一个仅对此可执行文件特定的库的lib3目录（项目中其他地方使用的库或对外部提供的库应位于src目录中）。这种结构提供了极大的灵活性，并可以轻松地扩展项目。随着添加更多类，可以方便地将它们分组到库中以提高编译速度。

\myGraphic{0.7}{content/chapter4/images/3.png}{图4.3：库的目录结构}

库应遵循与可执行文件相同的结构：在include目录中添加了一个可选的lib1目录。当库打算超出项目范围时，会包含此目录，其包含其他项目在编译期间将使用的公共头文件。

我们已经讨论了文件如何在目录结构中布局。现在，是时候看看单个CMakeLists.txt文件如何组合成一个项目。

\myGraphic{0.7}{content/chapter4/images/4.png}{图4.4：CMake如何将列表文件合并到单个项目中}

图中，每个框代表一个位于每个目录中的CMakeLists.txt列表文件，而其中的斜体标签代表每个文件执行的操作（从上到下）。再次从CMake的角度分析这个项目（有关详细信息，请查看ch04/05-structure目录中的示例）：

\begin{enumerate}
\item
执行从项目的根开始——即源树顶层的CMakeLists.txt列表文件。该文件将设置所需的最低CMake版本和相应的策略，设置项目名称、支持的语言和全局变量，并包含cmake目录中的文件，以便内容全局可用。

\item
下一步是调用add\_subdirectory(src bin)命令进入src目录的范围（希望将编译后的工件放在<binary\_tree>/bin，而不是/bin中）。

\item
CMake读取src/CMakeLists.txt文件，并发现其唯一目的是添加四个嵌套子目录：app1、app2、lib1和lib2。

\item
CMake进入app1的变量范围，并了解到另一个嵌套库lib3，它有自己的CMakeLists.txt文件；然后进入lib3的范围，这是对目录结构的深度优先遍历。

\item
lib3库添加了一个同名静态库目标，CMake返回到app1的父范围。

\item
app1子目录添加了一个依赖于lib3的可执行文件。CMake返回到src的父范围。

\item
CMake进入剩余的嵌套范围，并执行列表文件，直到所有add\_subdirectory()调用完成。

\item
CMake返回到顶层范围，并执行剩余的命令add\_subdirectory(test)。CMake每次都会进入新的范围，并执行相应列表文件中的命令。

\item
收集并检查所有目标的正确性。CMake现在有了生成构建系统所需的所有信息。
\end{enumerate}

前面的步骤按照在列表文件中编写命令的确切顺序发生。某些情况下，这个顺序很重要，有时可能没有那么关键。

那么，何时是创建包含项目所有元素的目录的正确时机呢？应该一开始就做——为未来创建所需的一切，并保持目录为空——还是等到实际上有了需要放入自己类别的文件再说？这是一个选择——可以遵循极限编程（XP）的规则YAGNI（你不会需要它），或者可以尝试使项目未来无忧，并为新来的开发者打下良好的基础。

尝试在这两种方法之间找到良好的平衡——如果怀疑项目可能有一天需要extern目录，那就添加（版本控制系统可能需要一个空的.keep文件来将目录签入仓库）。

另一种有效的做法是，通过创建README文件来指导他人放置他们的外部依赖，该文件概述了推荐的结构。这对于将来将要处理项目的经验不足的开发者有益。可能已经观察到了：开发者不愿意创建目录，尤其是在项目的根目录下。如果提供了一个好的项目结构，其他人就会倾向于遵循它。

有些项目几乎可以在任何环境中构建，而有些项目的要求非常特殊。顶层列表文件是确定适当行动方案的最佳位置。




