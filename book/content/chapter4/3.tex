随着我们的解决方案在代码行数和包含的文件数量上的增长，我们必须面对一个迫在眉睫的挑战：要么开始划分项目，要么面临被其复杂性所淹没的风险。解决这个问题有两种方法：分割 CMake 代码，并将源文件重新定位到子目录中。在这两种情况下，我们的目标都是遵循一个称为“关注点分离”的设计原则。简单来说，我们将代码分解成更小的部分，将紧密相关的功能组合在一起，同时保持其他代码片段的分离，以建立清晰的界限。

我们在第一章《CMake 的第一步》中讨论 listfiles 时简要提到了项目划分。我们谈到了 include() 命令，它允许 CMake 执行外部文件中的代码。

这种方法有助于分离关注点，但作用有限——专业代码被提取到单独的文件中，甚至可以在不相关的项目之间共享，但如果作者不小心，它仍然会以其内部逻辑污染全局变量范围。

你看，调用 include() 并不会在文件中已经定义的范围之外引入任何额外的范围或隔离。让我们通过一个例子来看看为什么这是一个潜在的问题，这个例子是支持小型汽车租赁公司的软件。它将有多个源文件定义软件的不同方面：管理客户、汽车、停车位、长期合同、维护记录、员工记录等。如果我们把所有这些文件都放在一个目录中，查找任何东西都会是一场噩梦。因此，我们在项目的主目录中创建了一些目录，并将相关的文件移动到其中。我们的 CMakeLists.txt 文件可能看起来像这样：

\filename{ch04/01-partition/CMakeLists.txt}

\begin{cmake}
cmake_minimum_required(VERSION 3.26.0)
project(Rental CXX)
add_executable(Rental
               main.cpp
               cars/car.cpp
               # more files in other directories
)
\end{cmake}

这都很棒，但正如你所看到的，我们仍然在顶层文件中包含了来自嵌套目录的源文件列表！为了增加关注点的分离，我们可以将源文件列表提取到另一个 listfile 中，并将其存储在 sources 变量中：

\filename{ch04/02-include/cars/cars.cmake}

\begin{cmake}
set(sources
    cars/car.cpp
    # more files in other directories
)
\end{cmake}

现在我们可以使用 include() 命令引用这个文件，以访问 sources 变量：

\filename{ch04/02-include/CMakeLists.txt}

\begin{cmake}
cmake_minimum_required(VERSION 3.26.0)
project(Rental CXX)
include(cars/cars.cmake)
add_executable(Rental
               main.cpp
               ${sources} # for cars/
)
\end{cmake}

CMake 会在与 add\_executable 相同的作用域中设置 sources，用所有文件填充该变量。这个解决方案有效，但它有几个缺点：

\begin{itemize}
\item
\textbf{嵌套目录中的变量将污染顶层作用域（反之亦然）：} 在一个简单的例子中这不是问题，但在更复杂的多级树结构中，使用了多个变量，这可以迅速成为一个难以调试的问题。如果我们有多个 included listfiles 定义了它们的 sources 变量呢？

\item
 \textbf{所有目录将共享相同的配置：} 这个问题在项目经过多年的成熟后会真正显现出来。没有粒度，我们必须统一对待每个源文件，我们不能为代码的某些部分指定不同的编译标志，选择更新的语言版本，以及在代码的选定区域消除警告。一切都是全局的，这意味着我们需要同时对所有翻译单元进行更改。

\item
\textbf{存在共享的编译触发器：} 任何配置的更改都意味着所有文件都需要重新编译，即使对其中一些文件来说这种更改是无意义的。

\textbf{所有路径都是相对于顶级目录的：} 注意在 cars.cmake 中，我们必须提供到 cars/car.cpp 文件的完整路径。这导致了很多重复的文本，损害了可读性，并且违反了干净编码的“不要重复自己”（DRY）原则（不必要的重复会导致错误）。重命名目录将是一场挣扎。
\end{itemize}

另一种方法是使用 add\_subdirectory() 命令，它引入了变量作用域等等。让我们来看一看。

\mySubsubsection{4.3.1.}{使用子目录管理作用域}

按照文件系统的自然结构来构建项目是一种常见的做法，其中嵌套的目录代表应用程序的离散元素，业务逻辑、GUI、API 和报告，最后是包含测试、外部依赖、脚本和文档的独立目录。为了支持这个概念，CMake 提供了以下命令：

\begin{shell}
add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])
\end{shell}

正如已经确立的，这将添加一个源目录到我们的构建中。可选地，我们可以提供一个路径，构建的文件将写入该路径（binary\_dir 或构建树）。EXCLUDE\_FROM\_ALL 关键字将禁用子目录中定义的目标的自动构建（我们将在下一章讨论目标）。这可能有用于分隔项目中不需要核心功能的部分（例如示例或扩展）。

add\_subdirectory() 将评估 source\_dir 路径（相对于当前目录）并解析其中的 CMakeLists.txt 文件。这个文件是在目录作用域内解析的，消除了前一种方法中提到的问题：

\begin{itemize}
\item
变量被隔离到嵌套作用域。

\item
嵌套工件可以独立配置。

\item
修改嵌套的 CMakeLists.txt 文件不需要重新构建不相关的目标。

\item
路径被定位到目录，并且如果需要，可以添加到父级包含路径。
\end{itemize}

这是我们的 add\_subdirectory() 示例的目录结构：

\begin{shell}
|--CMakeLists.txt
|-- cars
|   |-- CMakeLists.txt
|   |-- car.cpp
|   |-- car.h
|-- main.cpp
\end{shell}

在这里，我们有两个 CMakeLists.txt 文件。顶层文件将使用嵌套目录 cars：

\filename{ch04/03-add\_subdirectory/CMakeLists.txt}

\begin{cmake}
cmake_minimum_required(VERSION 3.26.0)
project(Rental CXX)
add_executable(Rental main.cpp)
add_subdirectory(cars)
target_link_libraries(Rental PRIVATE cars)
\end{cmake}

最后一行用于将 cars 目录的工件链接到 Rental 可执行文件。这是一个特定于目标的命令，我们将在下一章“第 5 章：使用目标”中详细讨论。

让我们看看嵌套的 listfile 长什么样：

\filename{ch04/03-add\_subdirectory/cars/CMakeLists.txt}

\begin{cmake}
add_library(cars OBJECT
    car.cpp
# more files in other directories
)
target_include_directories(cars PUBLIC .)
\end{cmake}

在这个例子中，我使用了 add\_library() 来生成一个全局可见的目标 cars，并使用 target\_include\_directories() 将 cars 目录添加到其公共包含目录中。这告诉 CMake cars.h 所在的位置，所以当使用 target\_link\_libraries() 时，main.cpp 文件可以在不提供相对路径的情况下使用该头文件：

\begin{cpp}
#include "car.h"
\end{cpp}

我们可以在嵌套的 listfile 中看到 add\_library() 命令，那么我们在这个例子中开始使用库了吗？实际上，没有。因为我们使用了 OBJECT 关键字，我们表示我们只对生成对象文件感兴趣（与上一个例子完全一样）。我们只是将它们分组在一个逻辑目标（cars）下。你可能已经对目标有了一些概念。保持这个想法——我们将在下一章解释细节。

\mySubsubsection{4.3.2.}{何时使用嵌套项目}

在前一节中，我们简要提到了在 add\_subdirectory() 命令中使用的 EXCLUDE\_FROM\_ALL 参数，用于指示代码库中的外部元素。CMake 文档建议，如果我们有这样的部分存在于源树中，它们应该在它们的 CMakeLists.txt 文件中有自己的 project() 命令，以便它们可以生成自己的构建系统并且可以独立构建。

还有其他场景这种情况会有用吗？当然。例如，一种场景是当你正在使用一个 CI/CD 管道中构建的多个 C++ 项目时（可能是在构建框架或一组库时）。或者，也许你正在将构建系统从传统的解决方案（如使用纯 makefile 的 GNU Make）移植过来。在这种情况下，你可能希望有一个选项，慢慢地将事物分解成更独立的片段——可能将它们放入单独的构建管道中，或者只是在更小的范围内工作，这样可以通过像 CLion 这样的 IDE 加载。你通过在嵌套目录的 listfile 中添加 project() 命令来实现这一点。只是不要忘记在它前面加上 cmake\_minimum\_required()。

既然支持项目嵌套，我们能否以某种方式连接并排构建的相关项目？

\mySubsubsection{4.3.3.}{保持外部项目外部化}

虽然在 CMake 中从另一个项目引用内部是技术上可能的，但这不是常规或推荐的做法。CMake 确实为这种情况提供了一些支持，包括使用 load\_cache() 命令从另一个项目的缓存中加载数据。然而，使用这种方法可能会导致循环依赖和项目耦合的问题。最好避免使用这个命令并做出决定：我们的相关项目应该是嵌套的，通过库连接，还是合并成一个项目？

这些是我们可用的划分工具：包括引入listfiles、添加子目录和嵌套项目。但是，我们应该如何使用它们，以保持项目易于维护、导航和扩展呢？为此，我们需要一个明确定义的项目结构。




















