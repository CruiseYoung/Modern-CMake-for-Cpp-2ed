CMake provides multiple ways of querying the environment with CMAKE\_ variables, ENV variables, and special commands. For example, collected information can be used to support cross-platform scripts. These mechanisms allow us to avoid using platform-specific shell commands that may not be easily portable or differ in naming across environments.

For performance-critical applications, it will be useful to know all the features of the building platform (for example, instruction sets, CPU core count, and more). This information can then be passed to the compiled binaries so that they can be tuned to perfection (we’ll learn how to do the passing in the next chapter). Let’s explore the native information provided by CMake.

\mySubsubsection{4.5.1.}{Detecting the operating system}

There are many occasions when it is useful to know what the target operating system is. Even as mundane a thing as a filesystem differs greatly between Windows and Unix in things such as case sensitivity, file path structures, the presence of extensions, privileges, and so on. Most commands present on one system won’t be available on another; they could be named differently (for example, ifconfig on Unix and ipconfig on Windows) or produce totally different output altogether.

If you ever need to support multiple target operating systems with a single CMake script, just check the CMAKE\_SYSTEM\_NAME variable so that you can act accordingly. Here’s a simple example:

\begin{cmake}
if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    message(STATUS "Doing things the usual way")
elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    message(STATUS "Thinking differently")
elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    message(STATUS "I'm supported here too.")
elseif(CMAKE_SYSTEM_NAME STREQUAL "AIX")
    message(STATUS "I buy mainframes.")
else()
    message(STATUS "This is ${CMAKE_SYSTEM_NAME} speaking.")
endif()
\end{cmake}

If needed, there’s a variable containing the operating system version: CMAKE\_SYSTEM\_VERSION. However, my recommendation is to try and make your solutions as system-agnostic as possible and use the built-in CMake cross-platform functionality. Especially for operations on filesystems, you should use the file() command described in the Appendix.

\mySubsubsection{4.5.2.}{Cross-compilation – what are host and target systems?}

Cross-compilation refers to the process of compiling code on one machine to be executed on a different target platform. For example, using the appropriate toolset, it is possible to compile applications for Android by running CMake on a Windows machine. Although cross-compilation is beyond the scope of this book, it’s important to understand how it impacts some parts of CMake.

One of the necessary steps to allow cross-compilation is setting the CMAKE\_SYSTEM\_NAME and CMAKE\_SYSTEM\_VERSION variables to the values appropriate for the operating system that you’re compiling for (the CMake documentation refers to it as the target system). The operating system used to perform the build is called a host system.

Regardless of the configuration, the information on the host system is always accessible in variables with the HOST keyword in their name: CMAKE\_HOST\_SYSTEM, CMAKE\_HOST\_SYSTEM\_NAME, CMAKE\_HOST\_SYSTEM\_PROCESSOR, and CMAKE\_HOST\_SYSTEM\_VERSION.

There are a few more variables with a HOST keyword in their name, so just keep in mind that they’re explicitly referencing the host system. Otherwise, all variables reference the target system (which is normally the host system anyway, unless we’re cross-compiling).

If you’re interested in reading more about cross-compilation, I suggest referencing the CMake documentation at \url{https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html}.

\mySubsubsection{4.5.3.}{Abbreviated variables}

CMake will predefine a few variables that will provide information about the host and target systems. If a specific system is used, an appropriate variable will be set to a non-false value (that is, 1 or true):

\begin{itemize}
\item
ANDROID, APPLE, CYGWIN, UNIX, IOS, WIN32, WINCE, WINDOWS\_PHONE

\item
CMAKE\_HOST\_APPLE, CMAKE\_HOST\_SOLARIS, CMAKE\_HOST\_UNIX, CMAKE\_HOST\_WIN32
\end{itemize}

The WIN32 and CMAKE\_HOST\_WIN32 variables will be true for 32- and 64-bit versions of Windows and MSYS (this value is kept for legacy reasons). Also, UNIX will be true for Linux, macOS, and Cygwin.

\mySubsubsection{4.5.4.}{Host system information}

CMake could provide more variables, but to save time, it doesn’t query the environment for rarely needed information, such as whether a processor supports MMX or what the total physical memory is. That doesn’t mean this information isn’t available – you just need to ask for it explicitly with the following command:

\begin{shell}
cmake_host_system_information(RESULT <VARIABLE> QUERY <KEY>...)
\end{shell}

We need to provide a target variable and a list of keys we’re interested in. If we provide just one key, the variable will contain a single value; otherwise, it will be a list of values. We can ask for many details about the environment and the OS:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{关键字}                & \textbf{描述}                                      \\ \hline
\endfirsthead
%
\endhead
%
HOSTNAME                    & Hostname                                         \\ \hline
FQDN                        & Fully qualified domain name                      \\ \hline
TOTAL\_VIRTUAL\_MEMORY      & Total virtual memory in MiB                      \\ \hline
AVAILABLE\_VIRTUAL\_MEMORY  & Available virtual memory in MiB                  \\ \hline
TOTAL\_PHYSICAL\_MEMORY     & Total physical memory in MiB                     \\ \hline
AVAILABLE\_PHYSICAL\_MEMORY & Available physical memory in MiB                 \\ \hline
OS\_NAME     & Output of uname -s if this command is present; either Windows, Linux, or Darwin \\ \hline
OS\_RELEASE                 & The OS sub-type, such as on Windows Professional \\ \hline
OS\_VERSION                 & The OS build ID                                  \\ \hline
OS\_PLATFORM & On Windows, \$ENV\{PROCESSOR\_ARCHITECTURE\}. On Unix/macOS, uname -m           \\ \hline
\end{longtable}

If needed, we can even query processor-specific information:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{关键字}                & \textbf{描述}                                   \\ \hline
\endfirsthead
%
\endhead
%
NUMBER\_OF\_LOGICAL\_CORES  & Number of logical cores                       \\ \hline
NUMBER\_OF\_PHYSICAL\_CORES & Number of physical cores                      \\ \hline
HAS\_SERIAL\_NUMBER         & 1 if the processor has a serial number        \\ \hline
PROCESSOR\_SERIAL\_NUMBER   & Processor serial number                       \\ \hline
PROCESSOR\_NAME             & Human-readable processor name                 \\ \hline
PROCESSOR\_DESCRIPTION      & Human-readable full processor description     \\ \hline
IS\_64BIT                   & 1 if processor is 64-bit                      \\ \hline
HAS\_FPU                    & 1 if processor has floating-point units       \\ \hline
HAS\_MMX                    & 1 if processor supports MMX instructions      \\ \hline
HAS\_MMX\_PLUS              & 1 if processor supports Ext. MMX instructions \\ \hline
HAS\_SSE                    & 1 if processor supports SSE instructions      \\ \hline
HAS\_SSE2                   & 1 if processor supports SSE2 instructions     \\ \hline
HAS\_SSE\_FP                & 1 if processor supports SSE FP instructions   \\ \hline
HAS\_SSE\_MMX               & 1 if processor supports SSE MMX instructions  \\ \hline
HAS\_AMD\_3DNOW             & 1 if processor supports 3DNow instructions    \\ \hline
HAS\_AMD\_3DNOW\_PLUS       & 1 if processor supports 3DNow+ instructions   \\ \hline
HAS\_IA64                   & 1 if IA64 processor is emulating x86          \\ \hline
\end{longtable}

\mySubsubsection{4.5.5.}{Does the platform have 32-bit or 64-bit architecture?}

In 64-bit architecture, memory addresses, processor registers, processor instructions, address buses, and data buses are 64 bits wide. While this is a simplified definition, it gives a rough idea of how 64-bit platforms are different from 32-bit platforms.

In C++, different architectures mean different bit widths for some fundamental data types (int and long) and pointers. CMake utilizes the pointer size to gather information about the target machine. This information is available through the CMAKE\_SIZEOF\_VOID\_P variable, and it will contain a value of 8 for 64 bits (because a pointer is 8 bytes wide) and 4 for 32 bits (4 bytes):

\begin{cmake}
if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    message(STATUS "Target is 64 bits")
endif()
\end{cmake}

\mySubsubsection{4.5.6.}{What is the endianness of the system?}

Architectures can be categorized as either big-endian or little-endian based on the byte order within a word or the natural unit of data for a processor. In a big-endian system, the most significant byte is stored at the lowest memory address, while the least significant byte is stored at the highest memory address. On the other hand, in a little-endian system, the byte order is reversed, with the least significant byte stored at the lowest memory address and the most significant byte at the highest memory address.

In most cases, endianness doesn’t matter, but when you’re writing bit-wise code that needs to be portable, CMake will provide you with a BIG\_ENDIAN or LITTLE\_ENDIAN value stored in the CMAKE\_<LANG>\_BYTE\_ORDER variable, where <LANG> is C, CXX, OBJC, or CUDA.

Now that we know how to query the environment, let’s shift our focus to the key settings of the project.

















