In this chapter, we covered valuable concepts that lay a strong foundation for building robust and future-proof projects. We discussed setting the minimum CMake version and configuring essential project aspects like name, languages, and metadata fields. Establishing these foundations enables our projects to scale effectively.

We explored project partitioning, comparing the use of basic include() with add\_subdirectory, which offers benefits such as scoped variable management, simplified paths, and increased modularity. The ability to create nested projects and build them separately proved useful in gradually breaking down code into more independent units. After understanding the available partitioning mechanisms, we delved into creating transparent, resilient, and extensible project structures. We examined CMake’s traversal of listfiles and the correct order of configuration steps. Next, we studied how we can scope the environment of our target and host machines, what the differences are between them, and what kind of information about the platform and system is available through different queries. We also covered configuring the toolchain, including specifying the required C++ version, handling vendor-specific compiler extensions, and enabling important optimizations. We learned how to test the compiler for required features and execute sample files to test compilation support.

Although the technical aspects covered so far are essential for a project, they are not sufficient to make it truly useful. To increase the project’s utility, we need to understand the concept of targets.
We briefly touched on the topic earlier, but now we are ready to approach it in full, as we finally have a solid understanding of related fundamentals. Targets, introduced in the next chapter, will play a crucial role in further enhancing the functionality and effectiveness of our projects.