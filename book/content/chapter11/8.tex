表面上，与恰当测试相关的复杂性似乎如此之大，以至于它们不值得付出努力。有多少代码在外运行却没有任何测试，这真是令人惊讶，主要的论点是测试你的软件是一项令人生畏的任务。我要补充的是：如果是手动进行，则更是如此。不幸的是，如果没有严格的自动化测试，代码中的任何问题都是不完整或根本不可见的。未经测试的代码可能更快编写（但并非总是如此）；然而，要阅读、重构和修复这些代码绝对要慢得多。

在本章中，我们概述了从一开始就进行测试工作的几个关键原因。其中最引人注目的是心理健康和良好的夜间睡眠。没有一个开发者躺在床上想：我等不及几个小时后被打扰，去处理一些生产环境中的火灾和修复错误。但是，认真地说，在将错误部署到生产环境之前捕捉它们，对你（和公司）可能是一个救命稻草。

当涉及到测试工具时，CMake在这里真正展现了它的强大。CTest在检测故障测试方面能发挥奇迹：隔离、洗牌、重复和超时。所有这些技术都非常有用，可以通过一个方便的命令行标志获得。我们了解到如何使用CTest来列出测试，过滤它们，并控制测试用例的输出，但最重要的是，我们现在知道全面采用标准解决方案的真正力量。任何用CMake构建的项目都可以进行完全相同的测试，而无需探究其内部细节。

接下来，我们结构化了项目，简化了测试过程，并在生产代码和测试运行器之间重用相同的对象文件。编写我们自己的测试运行器很有趣，但也许我们应专注于我们程序实际应解决的问题，并花时间接受一个流行的第三方测试框架。

说到这，我们学习了Catch2和GoogleTest的基础知识。我们进一步深入研究了GMock库的细节，并理解了测试替身如何工作以实现真正的单元测试。最后，我们使用LCOV设置了一些报告。毕竟，没有什么比硬数据更能证明我们的解决方案确实是经过全面测试的。

在下一章中，我们将讨论更多有用的工具，以提高我们源代码的质量，并找出我们甚至不知道存在的问题。