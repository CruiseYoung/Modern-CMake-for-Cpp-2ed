
最终，自动化测试不过是运行一个可执行文件，它将你的系统置于测试状态（SUT），执行你想要测试的操作，并检查结果是否符合预期。你可以将它们视为一种结构化的方式来完成句子“GIVEN\_<CONDITION>\_WHEN\_<SCENARIO>\_THEN\_<EXPECTED-OUTCOME>”并验证这对于SUT是否成立。一些资源建议按照这种非常方式命名你的测试函数：例如，GIVEN\_4\_and\_2\_WHEN\_Sum\_THEN\_returns\_6。

实现和执行这些测试的方法有很多，取决于你选择的框架、如何将其与SUT连接以及其确切设置。对于一个首次接触你项目的用户来说，即使是测试二进制文件的文件名这样的小细节也会影响他们的体验。由于没有标准的命名约定，一个开发者可能会将他们的测试可执行文件命名为test\_my\_app，另一个可能会选择unit\_tests，第三个可能会选择更不直观的名称，或者完全跳过测试。弄清楚要运行哪个文件、使用哪个框架、传递哪些参数以及如何收集结果都是用户宁愿避免的麻烦。

CMake通过一个单独的ctest命令行工具解决了这个问题。通过项目作者通过列表文件配置，它提供了一种标准化的运行测试方式。这个统一的界面适用于使用CMake构建的每个项目。遵循这个标准，你将享受到其他好处：将项目集成到持续集成/持续部署（CI/CD）管道变得更加容易，测试在IDEs（如Visual Studio或CLion）中显示得更方便。最重要的是，你只需最小努力就能获得一个健壮的测试运行工具。

那么，如何在已经配置的项目中使用CTest运行测试呢？你需要选择以下三种操作模式之一：

\begin{itemize}
\item
仪表盘模式

\item
测试模式

\item
构建并测试模式
\end{itemize}

仪表盘模式允许你将测试结果发送到一个名为CDash的单独工具，也来自Kitware。CDash收集并展示软件质量测试结果，在一个易于导航的仪表盘中。这个主题对于非常大的项目很有用，但超出了本书的范围。

测试模式的命令行如下：

\begin{shell}
ctest [<options>]
\end{shell}

在此模式下，应在使用CMake构建项目后，在构建树中运行CTest。有许多选项可用，但在深入讨论之前，需要解决一个小的不便：必须在构建树中运行ctest二进制文件，并且只有在项目构建之后才能运行。

为了简化操作，CTest提供了构建并测试模式。我们首先探讨这个模式，这样我们稍后可以全神贯注于测试模式。

\mySubsubsection{11.3.1.}{构建并测试模式}

要使用此模式，我们需要执行ctest后跟–{}-build-and-test：

\begin{shell}
ctest --build-and-test <source-tree> <build-tree>
      --build-generator <generator> [<options>...]
      [--build-options <opts>...]
      [--test-command <command> [<args>...]]
\end{shell}

本质上，这是测试模式的一个简单包装。它接受构建配置选项和–{}-test-command参数后的测试命令。重要的是要注意，除非你在–{}-test-command后包含ctest关键字，否则不会运行任何测试，如下所示：

\begin{shell}
ctest --build-and-test project/source-tree /tmp/build-tree --buildgenerator "Unix Makefiles" --test-command ctest
\end{shell}

在此命令中，我们指定源和构建路径，并选择一个构建生成器。所有这三个都是必需的，并遵循第1章“CMake的第一步”中详细描述的cmake命令的规则。

你可以添加更多参数，这些参数通常分为以下三个类别：配置控制、构建过程或测试设置。

配置阶段的参数如下：

\begin{itemize}
\item
-{}-build-options ——为cmake配置包含额外的选项。在–{}-test-command之前放置，必须放在最后。

\item
-{}-build-two-config —— 对CMake运行两次配置阶段。

\item
-{}-build-nocmake —— 跳过配置阶段。

\item
-{}-build-generator-platform —— 提供生成器特定的平台。

\item
-{}-build-generator-toolset —— 提供生成器特定的工具集。

\item
-{}-build-makeprogram —— 为基于Make或Ninja的生成器指定make可执行文件。
\end{itemize}

构建阶段的参数如下：

\begin{itemize}
\item
-{}-build-target —— 指定要构建的目标。

\item
-{}-build-noclean —— 在构建clean目标之前构建。

\item
-{}-build-project —— 命名正在构建的项目。
\end{itemize}

测试阶段的参数如下：

\begin{itemize}
\item
-{}-test-timeout —— 设置测试的时间限制，以秒为单位。
\end{itemize}

现在我们可以配置测试模式，方法是在–{}-test-command cmake后添加参数，或者直接运行测试模式。

\mySubsubsection{11.3.2.}{测试模式}

构建项目后，你可以在构建目录中使用ctest命令运行你的测试。如果你使用构建并测试模式，这将为你完成。在没有额外标志的情况下运行ctest通常足以满足大多数情况。如果所有测试都成功，ctest将返回0的退出代码（在类Unix系统中），你可以在CI/CD管道中验证，以防止将故障更改合并到生产分支。

编写好的测试可能与编写生产代码本身一样具有挑战性。我们将系统置于特定的状态（SUT），运行单个测试，然后销毁SUT实例。这个过程相当复杂，可能会产生各种问题：跨测试污染、时间并发干扰、资源争用、死锁导致的冻结执行，以及其他许多问题。

幸运的是，CTest提供了多种选项来缓解这些问题。你可以控制哪些测试运行、它们的执行顺序、它们生成的输出、时间限制和重复率，以及其他方面。接下来的部分将提供必要的上下文和最有用选项的简要概述。

\mySamllsection{查询测试}

我们可能需要做的第一件事是了解哪些测试实际上是为项目编写的。CTest提供了-N选项，它禁用执行并只打印列表，如下所示：

\begin{shell}
# ctest -N
Test project /tmp/b
  Test #1: SumAddsTwoInts
  Test #2: MultiplyMultipliesTwoInts
Total Tests: 2
\end{shell}

你可能想要使用-N与下一节中描述的过滤器一起使用，以检查当应用过滤器时哪些测试会被执行。

如果你需要一个可以被自动化工具消费的JSON格式，可以执行ctest并使用-{}-show-only=json-v1。

CTest还提供了一个使用LABELS关键字来分组测试的机制。要列出所有可用的标签（而无需实际执行任何测试），请使用-{}-print-labels。这个选项在手动定义测试时非常有用，例如在你的列表文件中使用add\_test()命令，然后你就可以通过测试属性指定个别标签，如下所示：

\begin{cmake}
set_tests_properties(<name> PROPERTIES LABELS "<label>")
\end{cmake}

然而，请注意，来自各种框架的自动化测试发现方法可能不支持这种标签细节的水平。

\mySamllsection{过滤测试}

有时你可能只想运行特定测试而不是整个套件。例如，如果你正在调试一个失败的单个测试，没有必要运行其他所有测试。你还可以使用这种机制来为大型项目跨多台机器分发测试。

这些标志将根据提供的正则表达式（regex）过滤测试，如下所示：

\begin{itemize}
\item
-R <r>, -{}-tests-regex <r> - 只运行<r>与匹配的测试名称的测试

\item
-E <r>, -{}-exclude-regex <r> - 跳过与<r>匹配的测试名称的测试

\item
-L <r>, -{}-label-regex <r> - 只运行与<r>匹配的标签的测试

\item
 -LE <r>, -{}-label-exclude <regex> - 跳过与<r>匹配的标签的测试
\end{itemize}

高级场景可以通过使用-{}-tests-information选项（或更短的-I形式）来实现。此选项采用逗号分隔的格式<start>,<end>,<step>,<test-IDs>的范围。你可以省略任何字段但保留逗号。<test-IDs>选项是一个逗号分隔的测试序号的列表。例如：

\begin{itemize}
\item
-I 3,, 将跳过测试1和2（执行从第三个测试开始）

\item
-I ,2, 将只运行第一个和第二个测试

\item
-I 2,,3 将每行运行第三个测试，从第二行开始

\item
-I ,0,,3,9,7 将只运行第三个、第九个和第七个测试
\end{itemize}

你还可以将这些范围指定在一个文件中，以在分布式方式上在多台机器上执行非常庞大的测试套件。当与-R一起使用-I时，只有满足两个条件的测试才会运行。如果你想运行满足任一条件的测试，请使用-U选项。如前所述，你可以使用-N选项来检查过滤的结果。

\mySamllsection{打乱测试}

编写单元测试可能会遇到一些意想不到的问题，其中一个令人惊讶的问题是测试耦合，即一个测试通过不完全设置或清除SUT的状态来影响另一个测试。换句话说，第一个执行的测试可能会“泄漏”其状态并污染第二个测试。这种耦合是坏消息，因为它引入了测试之间的未知、隐式关系。

更糟糕的是，这种错误往往隐藏在测试场景的复杂性中。我们可能会在随机失败的情况下检测到它，但相反的情况也同样可能：一个不正确的状态可能会导致测试在没有错误的情况下通过。这些错误的测试会给人一种安全感的错觉，这比完全没有测试还要糟糕。认为代码被正确测试的假设可能会鼓励更大胆的行动，导致意外的结果。

发现这类问题的一个方法是独立运行每个测试。通常，当直接从测试框架执行测试运行器而没有CTest时，这并不是情况。要运行单个测试，你需要向测试可执行文件传递一个特定于框架的参数。这允许你检测那些在套件中通过但在单独执行时失败的测试。

另一方面，CTest通过隐式地在子CTest实例中执行每个测试用例，有效地消除了所有基于内存的测试交叉污染。你甚至可以更进一步，添加-{}-force-new-ctest-process选项来强制使用单独的进程。

不幸的是，如果你的测试使用了外部、争用的资源，如GPU、数据库或文件，那么仅凭这一点可能无法奏效。我们可以采取的另一项预防措施是简单地随机化测试执行的顺序。引入这种变化通常足以最终检测出假性通过的测试。CTest支持这一策略，通过-{}-schedule-random选项。

\mySamllsection{处理失败}

这里有一个著名的约翰·C·麦克斯韦的名言：“尽早失败，经常失败，但总是向前失败。”向前失败意味着从我们的错误中学习。这就是我们运行单元测试（以及在生活的其他领域）时想要做的事情。除非你在运行测试时附带调试器，否则很难发现你犯了什么错误，因为CTest会保持简洁，只列出失败的测试，而不会实际打印它们的输出。

测试用例或SUT打印到标准输出的消息可能非常有价值，以确定确切出了什么问题。要看到它们，我们可以运行ctest并使用-{}-output-on-failure。或者，设置CTEST\_OUTPUT\_ON\_FAILURE环境变量也会有同样的效果。

根据解决方案的大小，在测试失败后停止执行可能是有意义的。这可以通过向ctest提供-{}-stop-on-failure参数来实现。

CTest会存储失败的测试名称。为了节省长时间测试套件的时间，我们可以专注于这些失败的测试，跳过运行通过测试，直到问题解决。这一特性是通过-{}-rerun-failed选项启用的（任何其他过滤器都将被忽略）。解决所有问题后，记得运行所有测试，以确保在此期间没有引入回归。

当CTest没有检测到任何测试时，这可能意味着两种情况：要么测试不存在，要么项目存在问题。默认情况下，ctest会打印一个警告消息并返回0的退出代码，以避免混淆。大多数用户都有足够的上下文来理解他们遇到了哪种情况以及下一步该做什么。然而，在某些环境中，ctest总是作为自动化流水线的一部分执行。在这种情况下，我们可能需要明确指出，缺乏测试应被视为错误（并返回非零退出代码）。我们可以通过提供-{}-no-tests=error参数来配置这种行为。对于相反的行为（无警告），请使用-{}-no-tests=ignore选项。

\mySamllsection{重复测试}

在职业生涯中，你迟早会遇到那些大多数时间都运行正确的测试。我想强调的是“大多数”。偶尔，这些测试会因为环境原因而失败：例如，由于错误地模拟时间、事件循环问题、异步执行的处理不当、并行性、哈希冲突以及其他在每次运行中都不会发生的非常复杂的场景。这些不可靠的测试被称为“易碎”测试。

这种不一致似乎是一个不太重要的问题。我们可能会说，测试不是一个真正的生产环境，这就是为什么它们有时会失败的原因。这种说法确实有一定的道理：测试不是为了复现每一个细节，因为这是不可能的。测试是一种模拟，是对可能发生的事情的近似，这通常就足够了。如果它们在下次运行时会通过，那么重新运行测试会有什么伤害呢？实际上，这确实有伤害。

有三个主要关注点，如下所述：

\begin{itemize}
\item
如果你的代码库中有足够多的易碎测试，它们将成为平滑交付代码变更的严重障碍。当你急于回家在周五下午，或者急于向客户交付一个严重问题的关键修复时，这尤其令人沮丧。

\item
你不能真正确定你的易碎测试是否因为测试环境的不完善而失败。可能是相反的情况：它们失败是因为它们复现了一个已经在生产环境中发生的罕见场景。这还没有明显到足以发出警报……但已经足够了。

\item
不是测试易碎，而是你的代码！环境有时会出问题——作为程序员，我们以确定性的方式处理这些问题。如果SUT以这种方式行为，那是一个严重的错误的迹象——例如，代码可能会从未初始化的内存中读取。
\end{itemize}

没有完美的方法来解决所有上述情况——可能的原因太多了。然而，我们可以通过多次运行它们并使用–repeat <mode>:<\#>option选项来增加识别易碎测试的机会。有三种模式可供选择，如下所述：

\begin{itemize}
\item
until-fail —— 运行测试<\#>次；所有运行都必须通过。

\item
until-pass —— 最多运行测试<\#>次；它必须至少通过一次。这适用于处理已知易碎但过于复杂和重要而无法调试或禁用的测试。

\item
after-timeout —— 最多运行测试<\#>次，但仅在测试超时时才重试。在繁忙的测试环境中使用。
\end{itemize}

一个普遍的建议是尽快调试易碎测试，或者如果它们不能被信任产生一致的结果，就尽快消除它们。

\mySamllsection{控制输出}

将每一条信息都打印到屏幕上会变得非常繁忙。CTest减少了噪音，并将执行的测试输出收集到日志文件中，只在常规运行中提供最有用的信息。当事情出错测试失败时，你可以期望一个总结，以及如果启用了-{}-output-on-failure，可能还会有一些日志，如之前所述。

从经验中我知道，“足够的信息”足够，直到它不再足够。有时，我们可能还想看到通过的测试的输出，以检查它们是否真的在正常工作（而不是悄悄地停止而没有错误）。要获取更详细的输出，可以添加-V选项（或-{}-verbose，如果你想在自动化流水线中明确表示）。如果这还不够，你可能会想要-VV或-{}-extra-verbose。对于极其深入的调试，可以使用–debug（但要做好准备，可能会出现带有所有细节的文本墙）。

如果你在寻找相反的情况，CTest也提供了“禅模式”，通过-Q或-{}-quiet启用。那时不会有任何输出（你可以停止担心，学会爱上这个bug）。这个选项似乎除了让人困惑之外没有其他用途，但要注意输出仍然会被存储在测试文件中（默认情况下存储在./Testing/Temporary）。自动化流水线可以检查退出代码是否为非零值，并收集日志文件进行进一步处理，而不会在主要输出中添加可能使不熟悉产品的开发者困惑的细节。

要将日志存储在特定路径，请使用-O <file>, -{}-output-log <file>选项。如果你的输出过长，有两个限制选项可以限制每个测试的字节数：-{}-test-output-size-passed 和-{}-test-output-size-failed <size>。

\mySamllsection{其他选项}

还有一些其他选项可以满足你日常测试需求，如下所述：

\begin{itemize}
\item
-C <cfg>, -{}-build-config <cfg> —— 指定要测试的配置。调试配置通常具有调试符号，使事情更容易理解，但发布版本也应该测试，因为重优化选项可能会影响SUT的行为。这个选项仅适用于多配置生成器。

\item
-j <jobs>, -{}-parallel <jobs> —— 设置并行执行的测试数量。这对于加快长时间测试的执行非常有用。请注意，在繁忙的环境中（在共享的测试运行器上），这可能会由于调度而产生不利影响。这可以通过下一个选项稍作缓解。

\item
-{}-test-load <level> —— 以一种方式安排并行测试，使得CPU负载不超过值（尽最大努力）。

\item
-{}-timeout <seconds> —— 指定单个测试的默认时间限制。
\end{itemize}

现在我们已经了解了在许多不同场景下如何执行ctest，接下来让我们学习如何添加一个简单的测试。



