
编译可以大致描述为，将用高级编程语言编写的指令转换为低级机器代码的过程。这使得我们能够使用类和对象等抽象概念来创建应用程序，而无需处理特定处理器的汇编语言中的繁琐细节。我们不需要直接与CPU寄存器打交道，考虑短跳或长跳，或管理栈帧。编译语言更具表现力、可读性和安全性，鼓励创建可维护的代码，同时尽可能提供性能。

在C++中，使用静态编译——整个程序必须转换为本地代码后才能执行。这与Java或Python等语言不同，后者在用户每次运行程序时都会实时解释和编译程序。每种方法都有其独特的优势。C++旨在提供大量高级工具，同时提供本地性能。C++编译器可以为几乎所有的架构生成独立的应用程序。

创建和运行C++程序涉及以下步骤：

\begin{enumerate}
\item
设计应用程序：这包括规划应用程序的功能、结构和行为。设计完成后，按照最佳实践仔细编写源代码，以保持代码的可读性和可维护性。

\item
将单独的.cpp实现文件（也称为翻译单元）编译成目标文件：这一步涉及将编写的高级语言代码转换为低级机器代码。

\item
将目标文件链接成单一的可执行文件：此步骤中，还会链接所有其他依赖项，包括动态和静态库。这个过程创建了一个可以在预期平台上运行的可执行文件。
\end{enumerate}

要运行程序，操作系统(OS)将使用一个名为加载器的工具，将程序的机器代码和所有必需的动态库映射到虚拟内存中。加载器然后读取程序头部，以确定执行应从何处开始，并开始运行指令。

在此阶段，程序的启动代码发挥作用。系统C库提供的名为\_start的特殊函数被调用。\_start函数收集命令行参数和环境变量，启动线程，初始化静态符号，并注册清理回调。在此之后，才会调用main()，开发者会在其中填入自己的代码。

所以，幕后进行了大量工作。本章关注前面列表中的第二步。通过考虑大局，可以更好地理解潜在问题可能起源于何处。尽管软件开发的复杂性看似难以理解，但其中并没有魔法。一切都有解释和原因。我们需要理解，即使编译步骤本身看起来是成功，程序在运行时可能会因编译方式而出错。编译器在其操作过程中无法检查所有边缘情况。因此，让我们找出编译器执行工作时实际发生的情况。

\mySubsubsection{7.2.1.}{编译如何工作}

编译是将高级语言转换为低级语言的过程，这涉及生成机器代码，即特定处理器可以直接执行的指令，以特定于给定平台的二进制目标文件格式。在Linux上，最常用的格式是可执行和可链接格式(ELF)，Windows使用PE/COFF格式规范，macOS为Mach对象（Mach-O格式）。

目标文件是单个源文件的直接翻译。每个文件都必须单独编译，然后由链接器组合成单一的可执行文件或库。这种模块化过程在修改代码时，因为只有程序员更新的文件需要重新编译，可以显著节省时间。

编译器必须执行以下阶段以创建目标文件：

\begin{itemize}
\item
预处理

\item
语法语义分析

\item
汇编

\item
优化

\item
代码生成
\end{itemize}

让我们详细地解释它们。

大多数编译器会自动调用，但预处理可视为实际编译之前的准备步骤。其作用是执行源代码的基本操作；它执行\#include指令，通过\#define指令和-D标志用定义的值替换标识符，调用简单宏，并根据\#ifdef、\#elif和\#endif指令有条件地包含或排除代码部分。预处理器对实际的C++代码一无所知，它充当一个高级的查找和替换工具。

然而，预处理器在构建高级程序中的作用至关重要。将代码划分为部分，并在多个翻译单元之间共享声明，是代码可重用的基础。

接下来是语言学分析，编译器进行更复杂的操作。逐字符扫描预处理后的文件（现在包括预处理器插入的所有头文件）。通过称为词法分析的过程，将字符组合成有意义的符号——关键字、运算符、变量名等。

然后，将这些符号组装成链，并检查它们的顺序和存在是否遵守C++的语法规则——这个过程称为语法分析或解析。这通常是生成大多数错误消息的阶段，因为其会识别语法问题。

最后，编译器进行语义分析。此阶段，编译器检查文件中的语句是否逻辑上合理。例如，确保满足所有类型正确性检查（不能将整数分配给字符串变量）。这种分析确保程序在编程语言的规则内有意义。

汇编阶段本质上是将这些符号，根据平台的可用指令集转换为CPU特定的指令。一些编译器实际生成汇编输出文件，然后将其传递给专用的汇编程序。这个程序生成CPU可以执行的机器代码。其他编译器直接在内存中生成此机器代码，这类编译器还提供生成人类可读汇编代码的文本输出的选项。

优化并不局限于编译过程中的单一步骤，而是每个阶段逐渐进行。在初始汇编产生之后，有一个明确的阶段专注于最小化寄存器使用和消除冗余代码。

一种有趣且值得注意的优化技术是内联展开或内联。这个过程中，编译器有效地“剪切”函数体，并将其“粘贴”到其调用的位置。

C++标准并未明确定义这种情况发生的条件——取决于实现。内联展开可以提高执行速度和减少内存使用，但同时也为调试带来了重大缺陷，执行的代码不再对应于源代码中的原始行。

代码生成阶段涉及将优化后的机器代码写入目标文件，格式与目标平台的规范相符。然而，这个目标文件尚未准备好执行——需要传递到链中的下一个工具，即链接器。链接器的工作是适当地重定位目标文件的部分，并解析对外部符号的引用，有效地准备文件执行。这一步骤标志着从美国信息交换标准代码(ASCII)源码，到可以直接由CPU处理的二进制可执行文件的转变。

这些阶段每一个都很重要，并且可以根据我们的具体需求进行配置。让我们看看如何使用CMake管理这个过程。

\mySubsubsection{7.2.2.}{初始配置}

CMake提供了几个可以影响编译每个阶段的命令：

\begin{itemize}
\item
target\_compile\_features(): 要求编译器具有特定的功能来编译这个目标。

\item
target\_sources(): 向已定义的目标添加源文件。

\item
target\_include\_directories(): 设置预处理器包含路径。

\item
target\_compile\_definitions(): 设置预处理器定义。

\item
target\_compile\_options(): 设置编译器特定的命令行选项。

\item
target\_precompile\_headers(): 设置要优化的外部头文件。
\end{itemize}

这些命令接受以下格式的类似参数：

\begin{shell}
target_...(<target name> <INTERFACE|PUBLIC|PRIVATE> <arguments>)
\end{shell}

所以使用此命令设置的属性会通过传递使用要求，如第5章“处理目标”中所述，并且可以用于可执行文件和库，并且这些命令都支持生成器表达式。

\mySamllsection{要求编译器的特定功能}

如第4章中的“检查支持的编译器功能”部分所讨论，预测问题并提供清晰的错误消息给软件用户至关重要——例如，当可用的编译器X不提供所需的功能Y时。这种方法比让用户解析，可能使用的兼容工具链产生的错误要友好得多。我们不想让用户将不兼容性问题归咎于我们的代码，而是他们过时的环境。

可以使用以下命令指定目标构建所需的所有功能：

\begin{shell}
target_compile_features(<target> <PRIVATE|PUBLIC|INTERFACE>
                        <feature> [...])
\end{shell}

CMake理解以下compiler\_id的C++标准和支持的编译器功能：

\begin{itemize}
\item
AppleClang: 适用于Xcode版本4.4+的Apple Clang

\item
Clang: Clang编译器版本2.9+

\item
GNU: GNU编译器版本4.4+

\item
MSVC: Microsoft Visual Studio版本2010+

\item
SunPro: Oracle Solaris Studio版本12.4+

\item
Intel: Intel编译器版本12.1+
\end{itemize}

CMake支持超过60种功能，以在官方文档中找到完整列表，该文档解释了CMAKE\_CXX\_KNOWN\_FEATURES变量。然而，除非需要非常具体的东西，否则建议选择指示C++标准的高级元功能：

\begin{itemize}
\item
cxx\_std\_14

\item
cxx\_std\_17

\item
cxx\_std\_20

\item
cxx\_std\_23

\item
cxx\_std\_26
\end{itemize}

看看以下示例：

\begin{cmake}
target_compile_features(my_target PUBLIC cxx_std_26)
\end{cmake}

这等同于set(CMAKE\_CXX\_STANDARD 26)和set(CMAKE\_CXX\_STANDARD\_REQUIRED ON)。不同之处在于target\_compile\_features()按目标工作，而不是全局地针对项目，如果需要为项目中的所有目标添加，可能会很繁琐。

关于CMake支持的编译器的详细信息，请参阅官方手册。

\mySubsubsection{7.2.3.}{管理目标源文件}

我们已经知道如何告诉CMake哪些源文件构成一个单独的目标，无论是可执行文件还是库。可以通过在add\_executable()或add\_library()命令中提供文件列表来实现。

随着解决方案的扩展，每个目标的文件列表也会增长。这可能导致一些相当长的add\_…()命令。要如何处理这种情况？一个方法可能是使用GLOB模式的file()命令，它可以收集子目录中的所有文件并将它们存储在变量中。可以将其作为目标声明的参数传递，不再担心文件列表：

\begin{cmake}
file(GLOB helloworld_SRC "*.h" "*.cpp")
add_executable(helloworld ${helloworld_SRC})
\end{cmake}

然而，这种方法并不推荐。CMake根据列表文件的变化生成构建系统，所以如果没有检测到变化，构建可能会在没有警告的情况下失败（这是开发者的噩梦）。此外，省略目标声明中的所有源文件，可能会干扰像CLion这样的IDE中的代码检查，因为它知道如何解析某些CMake命令，以理解项目。

在目标声明中使用变量，并不建议的另一个原因是：创建了一个间接层，导致开发者在阅读项目时必须解包目标定义。遵循这一建议，需要面临另一个问题：如何条件性地添加源文件？这是一个常见的场景，当处理特定于平台的实现文件时，如gui\_linux.cpp和gui\_windows.cpp。

target\_sources()命令允许源文件附加到已创建的目标：

\filename{ch07/01-sources/CMakeLists.txt}

\begin{cmake}
add_executable(main main.cpp)
if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    target_sources(main PRIVATE gui_linux.cpp)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    target_sources(main PRIVATE gui_windows.cpp)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    target_sources(main PRIVATE gui_macos.cpp)
else()
    message(FATAL_ERROR "CMAKE_SYSTEM_NAME=${CMAKE_SYSTEM_NAME} not
supported.")
endif()
\end{cmake}

这样，每个平台都获得了自己的兼容文件集。但长列表的源文件怎么办？好吧，只能接受有些事情还不完美，并继续手动添加。如果正在处理一个非常长的列表，可能会发现项目结构有些问题，也许应该将一些源文件划分为库。

既然已经了解了编译的基本知识，让我们深入探讨第一步——预处理。























