We have completed yet another chapter! Undoubtedly, compilation is a complex process. With all its edge cases and specific requirements, it can be difficult to manage without a robust tool. Thankfully, CMake does an excellent job supporting us here.

So, what have we learned so far? We began by discussing what compilation is and where it fits into the broader narrative of building and running applications in the OS. We then examined the stages of compilation and the internal tools that manage them. This understanding is invaluable for resolving complex issues that we might encounter in the future.

Next, we explored how to use CMake to verify whether the compiler available on the host meets all the necessary requirements for our code to build. As we have already established, it’s a significantly better experience for users of our solution to see a friendly message asking them to upgrade rather than an arcane error printed by an outdated compiler that can’t handle the new features of the language.

We briefly discussed how to add sources to already defined targets, then moved on to the configuration of the preprocessor. This was quite a substantial subject, as this stage brings all the bits of code together and determines which parts will be ignored. We talked about providing paths to files and adding custom definitions both individually and in bulk (along with some use cases).
Then, we discussed the optimizer; we explored all the general levels of optimization and what flags they implicitly add. We also went into detail about a few of them – finline, floop-unroll, and ftree-vectorize.

Finally, it was time to revisit the bigger picture and study how to manage the viability of compilation. We tackled two main aspects here – reducing the compilation time (which, by extension, helps maintain the programmer’s focus) and finding mistakes. The latter is extremely important for identifying what is broken and why. Setting the tools correctly and understanding why things happen greatly contributes to ensuring the quality of the code (and preserving our mental health).

In the next chapter, we’ll learn about linking and everything we need to consider in order to build libraries and use them in our projects.






























