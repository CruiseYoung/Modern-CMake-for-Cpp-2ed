我们已经完成了又一章的学习！毫无疑问，编译是一个复杂的过程。考虑到所有的边缘情况和特定要求，如果没有一个强大的工具，管理起来可能会很困难。幸运的是，CMake在这里为我们提供了支持。

那么，到目前为止我们学到了什么？从讨论编译是什么，以及它如何适应在操作系统中构建和运行应用程序开始。然后，检查了编译的各个阶段，以及管理它们的内部工具。这对于解决未来可能遇到的问题价值连城。

接下来，探讨了如何使用CMake来验证宿主上可用的编译器，是否满足代码构建的必要要求。正如已经建立的，对于解决方案的用户来说，最好看到一个友好的消息提示他们升级，而不是一个过时的编译器输出的神秘错误。后者无法处理语言的新特性，这无疑是显著更好的体验。

我们简要讨论了如何向已定义的目标添加源文件，然后继续讨论预处理的配置。这是一个相当重要的主题，因为这一阶段将所有代码片段汇集在一起，并确定哪些部分将忽略。我们讨论了提供文件路径和添加自定义定义的方法，既可以单独添加，也可以批量添加（以及一些使用案例）。 然后，讨论了优化器，探索了所有一般优化级别，以及它们隐式添加的标志。还详细讨论了其中的一些——finline、floop-unroll 和 ftree-vectorize。

最后，研究如何管理编译的可行性。在这里解决了两个主要方面——减少编译时间（这进而有助于保持程序员的专注）和查找错误。后者对于识别什么是错误的，以及为什么错误极为重要。正确设置工具并理解为什么会发生这些事情，对于确保代码质量（以及保持心理健康）做出了巨大贡献。

下一章中，我们将了解链接，以及构建库，并在我们的项目中使用构建的库。