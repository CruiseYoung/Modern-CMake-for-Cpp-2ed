
优化器将分析前几个阶段的结果，并使用多种策略，这些策略程序员通常不会直接使用，因为它们不符合干净代码的原则。但这没关系——优化器的基本作用是提高代码性能，力求降低CPU使用率、最小化寄存器使用和减少内存占用。当优化器遍历源代码时，它会将代码大量变形为几乎无法识别的形式，专门针对目标CPU。

优化器不仅会决定哪些函数可以被删除或压缩；它还会移动代码，甚至显著地复制代码！如果它能明确确定某些代码行是多余的，它甚至会从重要函数的中间删除这些代码（而你甚至不会注意到）。它通过回收内存，使得多个变量可以在不同时间占据同一个槽位。如果这样做可以减少几个周期的耗时，它甚至可以将你的控制结构重塑为完全不同的形式。

如果程序员手动将这些技术应用于源代码，它将变成一个糟糕的、难以阅读的混乱，难以编写和理解。然而，当编译器应用这些技术时，它们是有利的，因为编译器严格遵循提供的指令。优化器是一个不知疲倦的怪兽，它只有一个目的：加速执行速度，不管输出变得多么扭曲。这样的输出可能包含一些调试信息，如果我们在我们的测试环境中运行它，或者可能不包含，以使未经授权的人难以篡改。

每个编译器都有自己的独特技巧，这与它支持的平台和遵循的哲学相一致。我们将查看GNU GCC和LLVM Clang中最常见的一些，以了解什么是实用的和可实现的。

问题是——许多编译器默认情况下不会启用任何优化（包括GCC）。在某些情况下这是可以的，但在其他情况下就不那么好了。当你可以快速时，为什么要慢下来？为了纠正这一点，我们可以使用target\_compile\_options()命令，明确声明我们对编译器的期望。

这个命令的语法与本章中的其他命令类似：

\begin{shell}
target_compile_options(<target> [BEFORE]
                       <INTERFACE|PUBLIC|PRIVATE> [items1...]
                      [<INTERFACE|PUBLIC|PRIVATE> [items2...]
...])
\end{shell}

我们提供在构建目标时使用的命令行选项，我们还指定传播关键字。执行时，CMake会将给定的选项附加到目标的适当COMPILE\_OPTIONS变量中。如果我们要将它们前置，可以使用可选的BEFORE关键字。在某些情况下，顺序可能很重要，因此有选择是很有益的。

请注意，target\_compile\_options()是一个通用命令。它还可以用来提供其他类似编译器的参数，例如-D定义，CMake为此提供了target\_compile\_definition()命令。始终建议尽可能使用最专业的CMake命令，因为它们保证在所有支持的编译器上以相同的方式工作。

是时候讨论细节了。接下来的部分将介绍您可以在大多数编译器中启用的各种优化。

\mySubsubsection{7.4.1.}{通用级别}

优化器的所有不同行为都可以通过特定的标志深度配置，我们可以作为编译选项传递。了解所有这些标志需要花费大量时间，并且需要对编译器、处理器和内存的内部工作有深入的了解。如果我们只想得到在大多数情况下都很好的最佳方案，我们能做什么？我们可以寻求一个通用解决方案——一个优化级别指定器。

大多数编译器提供从0到3的四个基本优化级别。我们使用-O<级别>选项指定它们。-O0表示没有优化，通常它是编译器的默认级别。另一方面，-O2被认为是完全优化，它生成高度优化的代码，但代价是编译时间最慢。

还有一个介于两者之间的-O1级别，根据您的需要，它可以是一个很好的折衷方案——它启用了一定数量的优化机制，而不会过度减慢编译速度。

最后，我们可以使用-O3，它是与-O2相同的完全优化，但对子程序内联和循环向量化采取了更激进的方法。

还有一些优化变体，它们针对生成文件的大小（不一定是速度）进行优化——-Os。有一种超级积极的优化，-Ofast，它是一个不严格遵循C++标准的-O3优化。最明显的区别是使用-ffast-math和-ffinite-math标志，如果你的程序是关于精确计算（大多数是），你可能想要避免它。

CMake知道并非所有编译器都是相同的，因此，为了给开发者提供标准化的体验，它为编译器提供了一些默认标志。它们存储在系统范围（非目标特定）变量中，用于使用的语言（C++为CXX）和构建配置（DEBUG或RELEASE）：

\begin{itemize}
\item
CMAKE\_CXX\_FLAGS\_DEBUG 等于 -g

\item
CMAKE\_CXX\_FLAGS\_RELEASE 等于 -O3 -DNDEBUG
\end{itemize}

如您所见，调试配置不启用任何优化，而发布配置直接使用O3。如果您愿意，您可以使用set()命令直接更改它们，或者只添加一个目标编译选项，这将覆盖此默认行为。其他两个标志（-g，-DNDEBUG）与调试有关——我们将在本章的“为调试器提供信息”部分讨论它们。

诸如CMAKE\_<LANG>\_FLAGS\_<CONFIG>这样的变量是全局的——它们适用于所有目标。建议通过属性和命令（如target\_compile\_options()）配置您的目标，而不是依赖全局变量。这样，您可以更细致地控制目标。

通过选择带有-O<级别的>优化级别，我们间接设置了一系列标志，每个标志控制特定的优化行为。然后，我们可以通过附加更多标志来微调优化，如下所示：

\begin{itemize}
\item
使用-f选项启用它们 -finline-functions.

\item
使用-fno选项禁用它们 -fno-inline-functions.
\end{itemize}

这些标志中的一些值得更好地理解，因为它们经常会影响到程序的工作方式以及您如何调试它。让我们来看看。

\mySubsubsection{7.4.2.}{函数内联}

可以通过在类声明块内定义函数或显式使用inline关键字来鼓励编译器内联某些函数：

\begin{cpp}
struct X {
    void im_inlined(){ cout << "hi\n"; };
    void me_too();
};
inline void X::me_too() { cout << "bye\n"; };
\end{cpp}

是否内联一个函数最终由编译器决定。如果启用了内联，并且函数在单个地方使用（或者相对较小的函数在几个地方使用），则很可能会发生内联。

函数内联是一种有趣的优化技术。它通过从目标函数中提取代码并将其嵌入到函数被调用的所有位置来操作。这个过程替换了原始调用并节省了宝贵的CPU周期。

考虑使用我们刚刚定义的类的一个例子：

\begin{cpp}
int main() {
    X x;
    x.im_inlined();
    x.me_too();
    return 0;
}
\end{cpp}

如果没有内联，代码将在main()帧中执行，直到方法调用。然后，它将为im\_inlined()创建一个新的帧，在单独的作用域中执行，然后返回到main()帧。对于me\_too()方法也会发生同样的情况。

然而，当发生内联时，编译器将替换调用，如下所示：

\begin{cpp}
int main() {
    X x;
    cout << "hi\n";
    cout << "bye\n";
    return 0;
}
\end{cpp}

这并不是一个精确的表现，因为内联发生在汇编或机器代码级别（而不是源代码级别），但它确实提供了一个大致的想法。

编译器使用内联来节省时间。它绕过了创建和拆除新调用帧的需要，以及查找下一个要执行的指令的地址（并返回）的需求，并由于它们在接近的位置而增强了指令缓存。

然而，内联确实带来了一些显著的副作用。如果一个函数被多次使用，它必须被复制到所有位置，导致文件大小增大和内存使用增加。虽然这今天不如过去那么严重，但它仍然相关，特别是在为内存有限的低端设备开发软件时。

此外，内联对调试产生了严重影响。内联代码不再位于原始行号，使得跟踪变得更加困难，有时甚至不可能。这就是为什么在内联的函数中放置的调试器断点永远不会被命中（尽管代码仍然以某种方式执行）。为了绕过这个问题，您需要为调试构建禁用内联（以不测试确切发布构建版本为代价）。

我们可以通过为目标指定-O0（零级别）或直接处理负责内联的标志来实现这一点：

\begin{itemize}
\item
-finline-functions-called-once: 这只适用于GCC。

\item
-finline-functions: 这适用于Clang和GCC。

\item
-finline-hint-functions: 这只适用于Clang。
\end{itemize}

可以使用-fno-inline-…明确禁用内联，不过，为了详细信息，建议参考您特定编译器的文档版本。

\mySubsubsection{7.4.3.}{循环展开}

循环展开，也称为循环展开，是一种优化技术。这种策略旨在将循环转换为一系列完成相同结果的语句。因此，这种方法以程序的小尺寸换取执行速度，因为它消除了循环控制指令、指针算术和循环结束检查。

考虑以下示例：

\begin{cpp}
void func() {
    for(int i = 0; i < 3; i++)
    cout << "hello\n";
}
\end{cpp}

之前的代码将变成如下形式：

\begin{cpp}
void func() {
    cout << "hello\n";
    cout << "hello\n";
    cout << "hello\n";
}
\end{cpp}

结果将保持不变，但我们不再需要分配i变量，也不需要对其进行递增或与值3进行比较三次。如果我们在程序的生命周期中足够多次调用func()，即使是这样一个短小和简单的函数，其展开也会产生显著的差异。

然而，重要的是要理解两个限制因素。首先，循环展开只有在编译器知道或能够准确估计迭代次数时才有效。其次，循环展开可能会在现代CPU上产生不希望的结果，因为代码大小的增加可能会阻碍有效的缓存。

每个编译器提供了这个标志的略有不同的版本：

\begin{itemize}
\item
-floop-unroll: 这是GCC的版本。

\item
-funroll-loops: 这是Clang的版本。
\end{itemize}

如果您不确定，请广泛测试这个标志是否影响您的特定程序，并明确地启用或禁用它。请注意，在GCC上，它与隐式启用的-O3一起，作为-floop-unroll-and-jam标志的一部分被启用。

\mySubsubsection{7.4.4.}{循环向量化}

被称为单指令，多数据（SIMD）的机制是在20世纪60年代初为实现并行而开发的。正如其名称所暗示的，它旨在同时对多个数据执行相同的操作。让我们通过以下示例来实际看看这一点：

\begin{cpp}
int a[128];
int b[128];
// initialize b
for (i = 0; i<128; i++)
    a[i] = b[i] + 5;
\end{cpp}

通常，这样的代码会循环128次，但如果CPU能力强大，代码的执行可以通过同时计算两个或更多的数组元素而显著加速。这是由于连续元素之间不存在依赖关系以及数组之间的数据重叠。聪明的编译器可以将前一个循环转换为类似以下形式（这发生在汇编级别）：

\begin{cpp}
for (i = 0; i<32; i+=4) {
    a[ i ] = b[ i ] + 5;
    a[i+1] = b[i+1] + 5;
    a[i+2] = b[i+2] + 5;
    a[i+3] = b[i+3] + 5;
}
\end{cpp}

GCC将在-O3级别启用这样的循环向量化。Clang默认启用。两个编译器都提供不同的标志来启用/禁用特定情况下的向量化：

\begin{itemize}
\item
-ftree-vectorize -ftree-slp-vectorize: 这是在GCC中启用向量化的版本。

\item
-fno-vectorize -fno-slp-vectorize: 这是在Clang中禁用向量化的版本。
\end{itemize}

向量化的效率来自于CPU制造商提供的特殊指令的利用，而不是仅仅将循环的原始形式替换为展开版本。因此，手动实现相同性能水平是不切实际的（此外，它不会产生整洁的代码）。

优化器在提高程序的运行时性能方面起着关键作用。通过有效地运用其策略，我们可以得到更多的价值。效率不仅在于编码完成之后，而且在软件开发过程中也至关重要。如果编译时间过长，我们可以通过更好地管理过程来改善它们。














