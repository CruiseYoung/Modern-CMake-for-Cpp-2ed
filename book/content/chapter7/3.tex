
The preprocessor plays a huge role in the process of building. Maybe this is a little surprising, considering its functionality appears rather straightforward and limited. In the following sections, we’ll cover providing paths to included files and using the preprocessor definitions. We’ll also explain how we can use CMake to configure included headers.

\mySubsubsection{7.3.1.}{Providing paths to included files}

The most basic feature of the preprocessor is the ability to include .h and .hpp header files with the \#include directive, which exists in two forms:

\begin{itemize}
\item
Angle-bracket form: \#include <path-spec>

\item
Quoted form: \#include "path-spec"
\end{itemize}

As we know, the preprocessor will replace these directives with the contents of the file specified in path-spec. Finding these files may be a challenge. Which directories should be searched, and in what order? Unfortunately, the C++ standard doesn’t specify that exactly. We have to check the manual for the compiler in use.

Typically, the angle-bracket form will check standard include directories, which include the directories where standard C++ library and standard C library header files are stored in the system.

The quoted form starts by searching for the included file in the directory of the current file and then checks the directories for the angle-bracket form.

CMake provides a command to manipulate paths being searched for the included files:

\begin{shell}
target_include_directories(<target> [SYSTEM] [AFTER|BEFORE]
                           <INTERFACE|PUBLIC|PRIVATE> [item1...]
                          [<INTERFACE|PUBLIC|PRIVATE> [item2...]
...])
\end{shell}

This allows us to add custom paths that we want the compiler to scan. CMake will add them to compiler invocations in the generated buildsystem. They will be provided with a flag appropriate for the specific compiler (usually, it’s -I).

The target\_include\_directories() command modifies the target’s INCLUDE\_DIRECTORIES property by appending or prepending directories to it, based on whether the AFTER or BEFORE keyword is used. However, it’s still up to the compiler to decide whether the directories provided here will be checked before or after the default ones (usually, it’s before).

The SYSTEM keyword signifies to the compiler that the given directories should be treated as standard system directories (to be used with the angle-bracket form). For many compilers, these directories are passed with the -isystem flag.

\mySubsubsection{7.3.2.}{Preprocessor definitions}

Recall the preprocessor’s \#define and \#if, \#elif, and \#endif directives mentioned earlier when discussing the stages of compilation. Let’s examine the following example:

\filename{ch07/02-definitions/definitions.cpp}

\begin{cpp}
#include <iostream>
int main() {
#if defined(ABC)
    std::cout << "ABC is defined!" << std::endl;
#endif
#if (DEF > 2*4-3)
    std::cout << "DEF is greater than 5!" << std::endl;
#endif
}
\end{cpp}

As it stands, this example accomplishes nothing, as neither ABC nor DEF is defined (DEF would default to 0 in this example). We can easily change that by adding two lines at the top of this code:

\begin{cpp}
#define ABC
#define DEF 8
\end{cpp}

After compiling and executing this code, we can see both messages in the console:

\begin{shell}
ABC is defined!
DEF is greater than 5!
\end{shell}

This might seem simple enough, but what if we want to condition these sections based on external factors, such as an OS, architecture, or something else? The good news is that you can pass values from CMake to a C++ compiler, and it’s not complicated at all.

The target\_compile\_definitions() command will suffice:

\filename{ch07/02-definitions/CMakeLists.txt}

\begin{cmake}
set(VAR 8)
add_executable(defined definitions.cpp)
target_compile_definitions(defined PRIVATE ABC "DEF=${VAR}")
\end{cmake}

The preceding code will behave exactly like the two \#define statements, but we have the flexibility to use CMake’s variables and generator expressions, and we can place the command in a conditional block.

Traditionally, these definitions are passed to the compiler with the -D flag (for example, -DFOO=1) and some programmers continue to use this flag in this command:

\begin{cmake}
target_compile_definitions(hello PRIVATE -DFOO)
\end{cmake}

CMake recognizes this and will automatically remove any leading -D flags. It will also disregard empty strings, so the following command is perfectly valid:

\begin{cmake}
target_compile_definitions(hello PRIVATE -D FOO)
\end{cmake}

In this case, -D is a separate argument that becomes an empty string after removal and is subsequently ignored, thereby ensuring correct behavior.

\mySamllsection{Avoid accessing private class fields in your unit tests}

Some online resources recommend using a combination of specific -D definitions with \#ifdef/ ifndef directives for the purposes of unit testing. The most straightforward application of this approach is to enclose the public access specifier in conditional inclusions, effectively making all fields public when UNIT\_TEST is defined (class fields are private by default):

\begin{cpp}
class X {
#ifdef UNIT_TEST
    public:
#endif
    int x_;
}
\end{cpp}

While this technique offers convenience (allowing tests to directly access private members), it does not result in clean code. Ideally, unit tests should focus on verifying the functionality of methods within the public interface, treating the underlying implementation as a black box. Consequently, I suggest using this approach only as a last resort.

\mySamllsection{Using git commit to track a compiled version}

Let’s think about use cases that benefit from knowing details about the environment or filesystem. A prime example in professional settings might involve passing the revision or commit SHA used to build the binary. This could be achieved like so:

\filename{ch07/03-git/CMakeLists.txt}

\begin{cmake}
add_executable(print_commit print_commit.cpp)
execute_process(COMMAND git log -1 --pretty=format:%h
                OUTPUT_VARIABLE SHA)
target_compile_definitions(print_commit
                           PRIVATE "SHA=${SHA}")
\end{cmake}

The SHA could then be utilized in our application as follows:

\filename{ch07/03-git/print\_commit.cpp}

\begin{cpp}
#include <iostream>
// special macros to convert definitions into c-strings:
#define str(s) #s
#define xstr(s) str(s)
int main()
{
#if defined(SHA)
    std::cout << "GIT commit: " << xstr(SHA) << std::endl;
#endif
}
\end{cpp}

Of course, the preceding code requires the user to have Git installed and accessible in their PATH. This feature is particularly useful when the programs running on production servers are the result of a continuous integration/deployment pipeline. If there’s an issue with our software, we can quickly check which exact Git commit was used to build the faulty product.

Keeping track of an exact commit is extremely beneficial for debugging purposes. It’s straightforward to pass a single variable to C++ code, but how would we handle the scenario where dozens of variables need to be passed to our headers?

\mySubsubsection{7.3.3.}{Configuring the headers}

Passing definitions through target\_compile\_definitions() can become tedious with numerous variables. Wouldn’t it be easier to provide a header file with placeholders referencing these variables, and allow CMake to fill them in? Absolutely!

CMake’s configure\_file(<input> <output>) command enables you to generate new files from templates, like the following example:

\filename{ch07/04-configure/configure.h.in}

\begin{cmake}
#cmakedefine FOO_ENABLE
#cmakedefine FOO_STRING1 "@FOO_STRING1@"
#cmakedefine FOO_STRING2 "${FOO_STRING2}"
#cmakedefine FOO_UNDEFINED "@FOO_UNDEFINED@"
\end{cmake}

You can utilize this command as follows:

\filename{ch07/04-configure/CMakeLists.txt}

\begin{cmake}
add_executable(configure configure.cpp)
set(FOO_ENABLE ON)
set(FOO_STRING1 "abc")
set(FOO_STRING2 "def")
configure_file(configure.h.in configured/configure.h)
target_include_directories(configure PRIVATE
                           ${CMAKE_CURRENT_BINARY_DIR})
\end{cmake}

CMake then generates an output file like so:

\filename{ch07/04-configure/<build\_tree>/configured/configure.h}

\begin{cpp}
#define FOO_ENABLE
#define FOO_STRING1 "abc"
#define FOO_STRING2 "def"
/* #undef FOO_UNDEFINED */
\end{cpp}

As you can see, the @VAR@ and \$\{VAR\} variable placeholders were substituted with the values from the CMake listfile. Additionally, \#cmakedefine was replaced with \#define for defined variables and /* \#undef VAR */ for undefined ones. If you require an explicit \#define 1 or \#define 0 for \#if blocks, use \#cmakedefine01 instead.

You can incorporate this configured header in your application by simply including it in your implementation file:

\filename{ch07/04-configure/configure.cpp}

\begin{cpp}
#include <iostream>
#include "configured/configure.h"

// special macros to convert definitions into c-strings:
#define str(s) #s
#define xstr(s) str(s)

using namespace std;
int main()
{
#ifdef FOO_ENABLE
    cout << "FOO_ENABLE: ON" << endl;
#endif
    cout << "FOO_STRING1: " << xstr(FOO_STRING1) << endl;
    cout << "FOO_STRING2: " << xstr(FOO_STRING2) << endl;
    cout << "FOO_UNDEFINED: " << xstr(FOO_UNDEFINED) << endl;
}
\end{cpp}

By adding the binary tree to our include paths with the target\_include\_directories() command, we can compile the example and receive output populated from CMake:

\begin{shell}
FOO_ENABLE: ON
FOO_STRING1: "abc"
FOO_STRING2: "def"
FOO_UNDEFINED: FOO_UNDEFINED
\end{shell}

The configure\_file() command also includes a range of formatting and file-permission options, which we won’t delve into here due to length constraints. If you’re interested, you can refer to the online documentation for further details (see the Further reading section in this chapter).

Having prepared a complete compilation of our headers and source files, let’s discuss how the output code is shaped during the subsequent steps. While we don’t have direct influence over the linguistic analysis or assembling (as these steps adhere to strict standards), we can manipulate the configuration of the optimizer. Let’s explore how this can impact the end result.






